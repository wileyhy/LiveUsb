#!/bin/bash
## LiveUsb1

## Note, written for Fedora, see hardcoded /run/media/root'
## Note, style, function definition syntax, '(){ :' makes plain xtrace easier to read
## Note, style, `! [[ -e` doesn't show the '!' in xtrace, whereas `[[ ! -e` does.
## Note, idempotent script

# <> Debugging
set -aCuTeo pipefail # <>
set -x

:;: 'Variables likely to be manually changed with some regularity'
files_for_use_with_github_level_1=( ~/.ssh ~/.gnupg ~/.vimrc ~/.mozilla ~/.angband )
files_for_use_with_github_level_2=( ~/.config/gh )
files_for_use_with_github_level_3=( ~/.config/procps/toprc )
arrays_of_conf_files=( files_for_use_with_github_level_1 files_for_use_with_github_level_2 
  files_for_use_with_github_level_3 )

umask 077
hash -r

fn_bndry=' ~~~ ~~~ ~~~ '
fn_lvl=0
scr_nm=LiveUsb1

:;: 'Write to TTY'
TT=$( date +%H:%M:%S )
printf '  %s - Executing %s \n' "${TT}" "$0"
unset TT

##  FUNCTION DEFINITIONS BEGIN ##

:;: 'Functions TOC...'
  ## functions_this_script=(
  #+	'__vte_osc7()'
  #+	'__vte_prompt_command()'
  #+	'er_x()'
  #+	'get_pids_for_restarting()'
  #+  'gh_auth_login_command()'
  #+  'min_necc_git_cmds()'
  #+  'min_necc_rpms()'
  #+	'must_be_root()'
  #+  'pause_to_check()'
  #+  'reqd_user_files()'
  #+	'rm()'
  #+  'rsync_install_if_missing()'
  #+  'setup_network()'
  #+  'setup_time()'
  #+	'test_dns()'
  #+  'test_os()'
  #+  'trap_exit()'
  #+	'write_bashrc_strings()'
  #+)

functions_for_appending_into_bashrc=(
  '__vte_osc7'
  '__vte_prompt_command'
  'rm'
  )

:;: $'redefine all functions to be appended into bashrc, so start by \x60unset\x60ing them'
for AA in "${functions_for_appending_into_bashrc[@]}"
do
  unset -f "$AA"
done
unset AA

:;: 'Define __vte_osc7() -- for bashrc only'
# shellcheck disable=SC2317
function __vte_osc7(){ :
  local - cmd urlencode_o
  set -

  cmd=$( PATH="${PATH}:/usr/libexec:/usr/lib:/usr/lib64" command -v vte-urlencode-cwd )
  [[ -n ${cmd} ]] || return
  urlencode_o=$( "${cmd}" )

  ## Bug, what does this cmd do?
  printf '\033]7;file://%s%s\033' "${HOSTNAME}" "${urlencode_o:-"${PWD}"}"
}

:;: 'Define __vte_prompt_command() -- for bashrc only'
# shellcheck disable=SC2317
function __vte_prompt_command(){ :
  local - prompt_cmd pwd
  set -

  prompt_cmd=$( HISTTIMEFORMAT='' history 1 | sed 's/^ *[0-9]\+ *//' )
  prompt_cmd="${prompt_cmd//;/ }"
  pwd=~

  if ! [[ ${PWD} = ~ ]]
  then
    pwd="${PWD/#"${HOME}"\//\~\/}"
    pwd="${pwd//[[:cntrl:]]}"
  fi

  ## Bug, what does this cmd do?

  printf '\033[m\033]7;%s@%s:%s\033' "${USER}" "${HOSTNAME%%.*}" "${pwd}"
  __vte_osc7
}

:;: 'Define er_x()'
function er_x(){ local - hyphn="$-" exit_code="$?" _="${fn_bndry} er_x() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"

  printf '%s, Error, %s\n' "$scr_nm" "$*" >&2

  true "${fn_bndry} er_x() ENDS ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"

  exit "${exit_code}"
}

:;: 'Define get_pids_for_restarting()'
function get_pids_for_restarting(){ :
  local - hyphn="$-" _="${fn_bndry} get_pids_for_restarting() BEGINS ${fn_bndry} ${fn_lvl} to $((++fn_lvl))"

  ## Note,  local -Ig  picks up attributes and values from global scope and also outputs same to global
  #+  scope.
  # shellcheck disable=SC2034
  local - dnf_o pipeline1 pipeline2
  local -Ig a_pids pr_counter
  dnf_o=$( sudo -- nice --adjustment=-20 -- dnf needs-restarting 2> /dev/null || er_x "${nL}" )

  ## Note, this pipeline was broken out into its constituent commands in order to verify the values
  #+  mid-stream
  pipline1=$( awk '{ print $1 }' <<< "${dnf_o}" )
  pipline2=$( grep --only-matching --extended-regexp ^'[0-9]*'$ <<< "${pipline1}" )

  readarray -d '' -t a_pids < <( tr '\n' '\0' <<< "${pipline2}" )

  : 'lengths of variables' # <>
  : $(( ++pr_counter )) # <>
  : Lengths of vars, measurement no., "${pr_counter}" # <>
  : dnf_o,    "${#dnf_o}" # <>
  : pipline1, "${#pipline1}" # <>
  : pipline2, "${#pipline2}" # <>
  : a_pids,   "${#a_pids}" # <>

  true "${fn_bndry} get_pids_for_restarting()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define gh_auth_login_command()'
function gh_auth_login_command(){ :
  local - hyphn="$-" _="${fn_bndry} gh_auth_login_command() BEGINS ${fn_bndry} ${fn_lvl} to $((++fn_lvl))"
  # set -

  if gh auth status
  then
    gh auth logout
  fi

  ## Note, do not break this line with any backslashed newlines or it will fail and you'll have to
  #+  refresh auth manually; using short options for just this reason
  gh auth login -p 'ssh' -h 'github.com' -s 'admin:public_key,read:gpg_key,admin:ssh_signing_key' -w ||
    exit "${nL}"

  : 'gh - Use GitHub CLI as a credential helper'
  git config --global credential.helper "cache --timeout=3600"
  gh auth setup-git

  true "${fn_bndry} gh_auth_login_command()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'min_necc_git_cmds()'

function min_necc_git_cmds(){ :
  local - hyphn="$-" _="${fn_bndry} min_necc_git_cmds() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  set -

  git config --global 'user.email' '84648683+wileyhy@users.noreply.github.com'
  git config --global 'user.name' 'Wiley Young'
  git config --global 'user.signingkey' 'E287D0CF528591CE'

  true "${fn_bndry} min_necc_git_cmds()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define min_necc_rpms()'
function min_necc_rpms(){ :
  local - hyphn="$-" _="${fn_bndry} min_necc_rpms() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  local XX
  #set -

  for XX in git gh ShellCheck
  do
    if ! rpm --query "$XX"
    then
      set -x
      sudo dnf --assumeyes install "$XX"

      if ! sudo -- dnf needs-restarting
      then
        er_x "${nL}" needs-restarting "$XX"
      fi
      set -
    fi
  done

  true "${fn_bndry} min_necc_rpms()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define must_be_root()'
function must_be_root(){ :
  local - hyphn="$-" _="${fn_bndry} must_be_root() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  #set -

  if (( UID == 0 ))
  then
    er_x Must be a regular user and use sudo
  else
    sudo --validate || er_x "${nL}"
  fi

  true "${fn_bndry} must_be_root()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define pause_to_check()'
## Usage,   pause_to_check $nL
function pause_to_check() { EC=101 LL="$1"
  local - hyphn="$-" reply _="${fn_bndry} pause_to_check() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  set -

  read -N1 -p $'\nReady?\n[Y|y|(enter)|(space)] is yes\nAnything else is { no and exit }\n\n' -rst 600 reply

  case $reply in
    Y*|y*|$'\n'|' ' )
      printf '\n go \n'
      ;;\
    * )
      printf '\nexiting\n'
      exit
      ;;\
  esac
  
  local bndry_cmd
  if [[ $hyphn =~ x ]]; then bndry_cmd=echo; else bndry_cmd=true; fi
  "${bndry_cmd}"  "${fn_bndry} pause_to_check()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'reqd_user_files()'

function reqd_user_files(){ :
  local - hyphn="$-" _="${fn_bndry} reqd_user_files() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  #set -

    #declare -p files_for_use_with_github_level_1 # <>
    #declare -p files_for_use_with_github_level_2 # <>
    #declare -p files_for_use_with_github_level_3 # <>
    #: "${files_for_use_with_github_level_1[@]##*/}" # <>
    #: "${files_for_use_with_github_level_2[@]##*/}" # <>
    #: "${files_for_use_with_github_level_3[@]##*/}" # <>

    #files_for_use_with_github_level_1+=( ~/.foo) # <>
    #pause_to_check $nL # <>

local AA
local -n NN
local -p NN

:;: 'For each array of conf files and/or directories'
for AA in "${arrays_of_conf_files[@]}"
do
    #local -p AA
    #local | grep NN
    #declare | grep NN
  
  unset NN 
  local -p NN
  exit $nL
  NN="${AA}"

    local -p NN
    #pause_to_check "$nL"

  local BB

  :;: 'For each conf file or dir'
  for BB in "${!NN[@]}"
  do
      #command rm -fr "$BB" ; continue # <>
      #local -p AA BB NN 
      #echo '${NN[@]}: '"${NN[@]}"
      #echo '${NN[BB]}: '"${NN[BB]}"
	    #declare -p files_for_use_with_github_level_1 # <>
      #pause_to_check $nL # <>

    :;: 'If the conf FSO does not exist'
    if ! [[ -e ${NN[BB]} ]]
    then
      local pttn_label lsblk_out pttn_path mount_pt data_dir prev_umask

      pttn_label='29_Mar_2023'
      lsblk_out=$( lsblk --output label,path,mountpoints )
      pttn_path=$( awk -v lbl="${pttn_label}" '$1 ~ lbl { print $2 }' <<< "${lsblk_out}" )
      mount_pt="/run/media/root/${pttn_label}"
      data_dir="${mount_pt}/set-up-git"

      : 'If the USB device is NA, then exit'
      if [[ -z $pttn_path ]]
      then
        er_x "${nL} USB device not available"
      fi

      : 'Capture previous umask'
      read -r -a prev_umask < <( umask -p )
      umask 077

      : 'If the partition is not mounted which holds the data directory, then mount it'
      if ! grep --quiet "$mount_pt" <<< "${lsblk_out}" # <>
      then

        : 'Mountpoint must exist'
        if ! [[ -d "${mount_pt}" ]]
        then
          sudo -- mkdir --parents -- "${mount_pt}" || er_x "${nL}"
        fi

	: 'Mount operation'
        sudo -- mount -- "${pttn_path}" "${mount_pt}" || er_x "${nL}"
      fi

      ## Bug: if just one file is missing, then re-install all files?  No.

        #declare -p files_for_use_with_github_level_2 # <>
        #declare -p files_for_use_with_github_level_3 # <>
        #pause_to_check "$LINENO"

      local source_file dest_dir
      source_file="${data_dir}/${NN[BB]##*/}"
      dest_dir="${NN[BB]%/*}"

      #local -a      files_lev_1_source
      #readarray -t  files_lev_1_source < <(
        #printf "${data_dir}"'/%s\n' "${files_for_use_with_github_level_1[@]#~/}" )
      #local -a      files_lev_2_source
      #readarray -t  files_lev_2_source < <(
        #printf "${data_dir}"'/%s\n' "${files_for_use_with_github_level_2[@]#~/}" )
      #local -a      files_lev_3_source
      #readarray -t  files_lev_3_source < <(
        #printf "${data_dir}"'/%s\n' "${files_for_use_with_github_level_3[@]#~/}" )
      #local -a      files_lev_1_dest
                    #files_lev_1_dest=~
      #local -a      files_lev_2_dest
                    #files_lev_2_dest=~/.config
      #local -a      files_lev_3_dest
                    #files_lev_3_dest=~/.config/procps

        #declare -p files_lev_{1,2,3}_{source,dest} # <>
        
        pause_to_check $nL # <>

    ## Bug? Use `install` instead of `rsync`?

      rsync_install_if_missing  "${source_file}" "${dest_dir}"

      #rsync_install_if_missing  files_lev_1_source "${files_lev_1_dest}"
      #rsync_install_if_missing  files_lev_2_source "${files_lev_2_dest}"
      #rsync_install_if_missing  files_lev_3_source "${files_lev_3_dest}"

        pause_to_check $nL # <>
	      #exit 101 # <>

      builtin "${prev_umask[@]}"
      break
    fi
  done
done
unset AA NN
    ## Bug: gh login breaks before here
    EC=101 LL="$LINENO" exit # <>
    #exit 102 # <>

  true "${fn_bndry} reqd_user_files()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

## Bug, this rm function is broken. if the user doesn't include '--' the file is not removed

:;: 'Define rm() -- for bashrc only'
## Note, rm(), command shadowing is intended in this case
function rm(){ :
  local - 
  #set -

  #local fn_command_line
  #fn_command_line="${FUNCNAME[0]} $*"
 
  :;: 'Input must exist'
  [[ ${#@} -eq 0 ]] && return "$LINENO"
    
  :;: 'For each positional parameter'
  local HH end_of_options opts_rm args_rm
  
  for HH
  do
    : 'If "End of Options" has (not) been reached'
    if ! [[ ${end_of_options:=} = 'has_been_reached' ]]
    then
      case "${HH}" in
        --version )
          command -- rm --version
          ;;
        --help )
          command -- rm --help
          ;;
        -- )
          end_of_options='has_been_reached'
          opts_rm+=( "${HH}" )
          ;;    
        -f|--force|-i|--interactive|--interactive=always|-I|--interactive=once|--interactive=never|\
        --one-file-system|--no-preserve-root|--preserve-root|--preserve-root=all|-r|-R|--recursive|\
        -d|--dir|-v|--verbose )
          opts_rm+=( "${HH}" )
          ;;    
        * )
          : 'No options found; options have concluded'
          end_of_options='has_been_reached'
          
          : 'If there is no next pos-parm'
          if [[ -z ${2:-} ]] || ! [[ $2 = -- ]]
          then
            : '...then force end of arguments on the CLI'
            opts_rm+=( -- )
          else
            : $'...or if the next pos-parm isn\x60t a valid FSO (File System Object)'
            if ! [[ -e $2 ]] || ! [[ -d $2 ]] 
            then
              : '...then force end of arguments on the CLI'
              opts_rm+=( -- )
            fi
          fi

          if [[ -e ${HH} ]]
          then
            JJ=$( realpath -e "${HH}" )
            args_rm+=( "${JJ}" )
          else
            : $'rm: unrecognized option \x27'"${HH}"$'\x27\n'
            : $'Try \x27rm --help\x27 for more information.'
          fi
          unset JJ
          ;;
      esac
    else 
      : 'Yes, so options are over and only arguments are processed'

      if [[ -e ${HH} ]]
      then
        II=$( realpath -e "${HH}" )
        args_rm+=( "${II}" )
      else
        : $'fn_rm: cannot access \x27'"${HH}"$'\x27: No such file or directory\n'
        : $'GNU \x60rm\x60 silently ignores such inputs'
      fi
      unset II
    fi

    : 'Restart loop'
    shift
  done
  : 'End of loop'

  : 'Sanity check for options and arguments'
  [[ -z ${opts_rm:=} ]] && opts_rm=( -- )

  :;: '"Recycle bin" must exist'
  local delete_d
  delete_d=~/.rm.d

  if ! [[ -e ${delete_d} ]] || ! [[ -d ${delete_d} ]]
  then
      command -- mkdir --mode 0700 --verbose -- "${delete_d}" || return "$LINENO"
  fi

  :;: 'If optargs exist, then  mv  the file into the recycle bucket, appending the time'
  if [[ -n ${args_rm[*]:0:8} ]]
  then
    local time_sfx 
    time_sfx=$( date --utc +%s )
    
    command -- mv --verbose -- "${HH}" "${delete_d}/${HH}.${time_sfx}" || return "$LINENO"
  fi
}

function rsync_install_if_missing(){ :
  local - hyphn="$-" _="${fn_bndry} rsync_install_if_missing() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  set -x

  local HH fn_target_dir fn_umask fn_source_array
  #set -
  fn_source_array="$1"
  fn_target_dir="$2"

  if [[ -e "${fn_target_dir}" ]]
  then
    if ! [[ -d "${fn_target_dir}" ]]
    then
      er_x "$nL" "${fn_target_dir}"
    fi
  else
    read -r -a fn_umask < <( umask -p )
    umask 077
    mkdir --verbose --parents -- "${fn_target_dir}"
    builtin "${fn_umask[@]}"
    unset fn_umask
  fi

  for HH in "${fn_source_array[@]}"
  do
    if ! [[ -e ${fn_target_dir}/${HH##*/} ]]
    then
      sudo -- rsync --archive --checksum -- "${HH}"  "${fn_target_dir}"
    fi
  done
  unset HH fn_source_array fn_target_dir

  true "${fn_bndry} rsync_install_if_missing() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
}


:;: 'Define setup_network()'
## Note, 1 is Google; A is Comcast; both are global variables
function setup_network(){ :
  local - hyphn="$-" _="${fn_bndry} setup_network() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  set -x

  dns_srv_1=8.8.8.8
  dns_srv_A=75.75.75.75
  readonly dns_srv_1 dns_srv_A

  if ! test_dns "${dns_srv_1}" || ! test_dns "${dns_srv_A}"
  then
    printf '\n%s, Attempting to connect to the internet... \n\n' "$scr_nm"

    : 'Try to get NetworkManager up and running'
    sudo -- nice --adjustment=-20 -- systemctl start -- NetworkManager.service
    wait -f

    : 'Turn on networking'
    sudo -- nmcli n on

    : 'Turn on WiFi'
    sudo -- nmcli r wifi on

    : 'Get interface name(s)'
    readarray -d '' -t ifaces < <( nmcli --terse c |
      awk --field-separator ':' '$1 !~ /lo/ { printf "%s\0", $1 }' )

    : 'Connect the interface'
    case "${#ifaces[@]}" in
      0 )
        er_x "line,${nL}, No network device available"
        ;;\
      1 )
        nmcli c up "${ifaces[*]}"
        sleep 5
        ;;\
      * )
        er_x "line ${nL}, Multiple network devices available"
        ;;\
    esac

    if ! test_dns "${dns_srv_1}" || ! test_dns "${dns_srv_A}"
    then
      printf '\n%s  Network  Giving up; exiting.\n\n' "$scr_nm"
    else
      printf '\n%s  Network  Success! \n\n' "$scr_nm"
    fi
  fi

  ## Clean up from Network
  ## Note, dns_srv_A will be used at the end of the script
  unset -f test_dns

  true "${fn_bndry} setup_network()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define setup_time()'
function setup_time(){ :
  local - hyphn="$-" _="${fn_bndry} setup_time() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"

  sudo -- timedatectl set-local-rtc 0
  sudo -- timedatectl set-timezone America/Vancouver
  sudo -- nice --adjustment=-20 -- systemctl start chronyd.service || er_x "line ${nL}"
  sudo -- chronyc makestep > /dev/null

  true "${fn_bndry} setup_time()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define test_dns()'
function test_dns(){ :
  local - hyphn="$-" _="${fn_bndry} test_dns() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  #set -

  sudo -- ping -c 1 -W 15 -- "$1" > /dev/null 2>&1
  ping_exit_code=$?

  true "${fn_bndry} test_dns()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
  return "${ping_exit_code}"
}

:;: 'Define test_os()'
function test_os(){ :
  local - hyphn="$-" _="${fn_bndry} test_os() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"

  local kern_rel
  kern_rel=$( uname --kernel-release )

  ## Note, test of $kern_rel is a test for whether the OS is Fedora (ie, "fc38" or "Fedora Core 38")
  if ! [[ ${kern_rel} =~ \.fc[0-9]{2}\. ]]
  then
    er_x "${LINENO}, OS is not Fedora"
  fi

  true "${fn_bndry} test_os()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

## Bug, these var assignments $exit_trap_ec and $lineno only fail when they're on line number >=2
#+  of  trap  "args section" ??

:;: 'Define trap_exit()'
## Note: these variable assignments must be on the 1st line of the funtion in order to capture correct data
# shellcheck disable=SC2317
function trap_exit(){ local - hyphn="$-" exit_trap_ec="${EC:-$?}" lineno="${LL:-$LINENO}"
  true "${fn_bndry} trap_exit() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  set -

  if [[ -e ${tmpd} ]]
  then
    command rm --one-file-system --preserve-root=all --force --recursive -- "${tmpd}"
  fi

  trap - EXIT

  if [[ ${exit_trap_ec} -eq '00' ]]
  then
    : "End of script, line ${lineno}"
  else
    : 'End of EXIT trap'
  fi

  true "${fn_bndry} trap_exit()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"

  builtin exit "${exit_trap_ec}"
}

:;: 'Define write_bashrc_strings()'
function write_bashrc_strings(){ :
  local - hyphn="$-" _="${fn_bndry} write_bashrc_strings() BEGINS ${fn_bndry} ${fn_lvl} to $((++fn_lvl))"

  local JJ file_x Aa_index Aa_element
  local -n fn_nameref
  #set -

  :;: 'Certain parameters must be defined and have non-zero values'
  (( $# == 0 )) && er_x "line ${nL}"
  (( ${#files_for_use_with_bash[@]} == 0 )) && er_x "line ${nL}"

  for JJ
  do :;: 'Loop A - For each set of strings to append into bashrc'

    fn_nameref="$JJ"

    for file_x in "${files_for_use_with_bash[@]}"
    do :;: 'Loop B - For each .bashrc'

      : "file_x  ${file_x}"

      for Aa_index in "${!fn_nameref[@]}"
      do :;: 'Loop C - For each definition (function or parameter)'

        : "Aa_index  ${Aa_index}"
        Aa_element="${fn_nameref[${Aa_index}]}"

        :;: '(1) If the definition is not yet written into the file...'
        if ! sudo -- grep --quiet --fixed-strings "## ${Aa_index}" -- "${file_x}"
        then

          : 'Then write the function definition into the file'
          printf '\n## %s \n%s \n' "${Aa_index}" "${Aa_element}" |
            sudo -- tee --append -- "${file_x}" > /dev/null || er_x "${nL}"
        else
          : 'Definition exists, skipping'
        fi

        :;: '(2) If there is an alias by the same name, then delete it from the bashrc file at hand...'
        sudo -- sed --in-place "/^alias ${Aa_index##* }=/d" -- "${file_x}"

        : 'Loop C - shut' ;:
      done
      unset Aa_element
      :;: 'Loop C - complete'

      :;: 'For each file, if absent add a newline at EOF'
      if sudo -- tail --lines 1 -- "${file_x}" | grep --quiet --extended-regexp '[[:graph:]]'
      then
        printf '\n' | sudo -- tee --append -- "${file_x}" > /dev/null
      fi

      : 'Loop B - shut' ;:
    done

    :;: 'Reset for the next loop, assuming there is one'
    ## Note, ?? use  unset  so that values from previous loops will not interfere with the current loop
    unset -n fn_nameref
    shift

    : 'Loop A - shut' ;:
  done
  true "${fn_bndry} write_bashrc_strings()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

##  FUNCTION DEFINITIONS COMPLETE ##

  #EC=101 LL="$LINENO" exit # <>
  set -x # <>

:;: 'Define trap on EXIT'
trap trap_exit EXIT

:;: 'Test OS'
test_os

:;: 'Vars, dirs, etc'
## Bug, only way to export namerefs?  `declare -nx nL=...`

:;: 'Vars... -- Error handling, variables and functions'
## Note, variable assignments, Backslash escape bc  sed -i
# shellcheck disable=SC1001
declare -nx nL=L\INENO

:;: 'Vars... -- PATH'
PATH='/usr/bin:/usr/sbin'
export PATH

:;: 'Vars... -- Working dir'
unset tmpd
tmpd=$( TMPDIR='' mktemp --directory --suffix=-LiveUSB 2>&1 || er_x "${nL}" )
[[ -d ${tmpd} ]] || er_x "${nL}"

:;: 'Vars... -- Other environment variables'
## Note, Initialize some env vars found in sourced files, as a workaround for nounset'
## Note, local style, inline comments, ie, ': foo ## Note, blah', are useful for rebutting false positives
#+  from ShellCheck
LC_ALL=''
PS1=''
# shellcheck disable=SC2034
declare BASHRCSOURCED USER_LS_COLORS ## Note, /etc/bashrc and /etc/profile.d/colorls.*sh on Fedora 38

  #EC=101 LL="$LINENO" exit # <>
  set -x # <>

:;: '<Logs>'
#exec 3>&1 4>&2 # <Logs>
#trap 'set - ; exec 2>&4 1>&3' EXIT HUP INT QUIT USR2 TERM # <Logs>
#exec 1> ./Log_begin-1.txt 2>&1 # <Logs>

  #EC=101 LL="$LINENO" exit # <>
  set -x # <>

:;: 'Regular users with sudo, only'
must_be_root

  #EC=101 LL="$LINENO" exit # <>
  set -x # <>

  ## Bug: gh login breaks after here
  
:;: 'Certain files must have been installed from off-disk'
reqd_user_files

  ## Bug: gh login breaks before here

  EC=101 LL="$LINENO" exit # <>
  set -x # <>

:;: 'Network'
setup_network

  EC=101 LL="$LINENO" exit # <>
  set -x # <>

:;: 'Time'
setup_time

:;: 'Minimum necessary rpms'
min_necc_rpms

:;: 'Minimum necessary git commands'
min_necc_git_cmds

  #EC=101 LL="$nL" exit # <>
  set -x # <>

:;: 'gh -- github CLI configuration'
declare -A github_configs
github_configs=( [editor]=vim [browser]=firefox [pager]=less [git_protocol]=ssh )
gh_config_list_out=$( gh config list | tr '\n' ' ' )

for KK in "${!github_configs[@]}"
do
  if ! [[ ${gh_config_list_out} = "${KK}=${github_configs[$KK]}" ]]
  then
    gh config set "${KK}" "${github_configs[$KK]}"
  fi
done
unset gh_config_list_out github_configs KK

:;: 'gh -- Login to github'
## Note, executing this command just once
if ! gh auth status || [[ $( gh auth status |& grep --count $'\xe2\x9c\x93' ) -ne 4 ]]
then
  if ! pgrep 'firefox'
  then
    firefox --browser &
    pause_to_check "$nL"
    gh_auth_login_command
  fi
fi

:;: 'gh -- Get SSH & GPG keys'
for QQ in ssh-key gpg-key
do
  if ! gh "${QQ}" list > /dev/null
  then
    gh_auth_login_command
  fi
done
unset QQ

:;: 'gh -- Review auth'
printf '\n'
gh auth status

  #exit "$nL" # <>

:;: 'Bash'
## Note, this section is for .bashrc. VTE functions are from Fedora 38, Sun 09 July 2023, altered from vte.sh
## Note,  set [-|-x] , letting xtrace expand this  tput  command alters all xtrace colorization

:;: 'Env vars for bashrc'

:;: 'Color code assigned to PS0, ducking xtrace'
if [[ -o xtrace ]]
then
  set -
  PS0=$( tput setaf 43 )
  set -x
else
  PS0=$( tput setaf 43 )
fi
PS1="[\\u@\\h]\\\$ "
PROMPT_COMMAND=( [0]="printf '%b' '\\033[m'" [1]="__vte_prompt_command" )
BROWSER=$( command -v firefox )
EDITOR=$( command -v vim )

  ## Note, TERM_SESSION_ID, 1, added in order to identify which TTY is using which terminal emulator
  #+  program. See also, https://stackoverflow.com/questions/42710685/bash-identify-a-terminal-session
  #TERM_SESSION_ID="${TERM_SESSION_ID:-}"
  #if [[ -z "$TERM_SESSION_ID" ]]
  #then
  #TERM_SESSION_ID=$( uuidgen )
  #export TERM_SESSION_ID
  #fi

declare -A bashrc_strings_1 bashrc_strings_2
files_for_use_with_bash=( /root/.bashrc ~/.bashrc )
missing_fns=()

:;: 'Append user variables and functions into .bashrc.'
## Note, these arrays include some command substitutions which depend on some function definitions, which in
#+ turn must be defined prior to defining these arrays
for UU in "${functions_for_appending_into_bashrc[@]}"
do
  if [[ $( declare -pF "${UU}" 2>&1 ) =~ 'not found' ]]
  then
    missing_fns+=( "${UU}" )
  fi
done
unset UU

if (( ${#missing_fns[@]} > 0 ))
then
  er_x "${nL}", "${missing_fns[@]}"
fi

:;: 'Define bashrc_strings_*'
## Note, you want for these array values to each represent just one parameter or function
bashrc_strings_1=(            ['function __vte_osc7']="function $(  declare -pf __vte_osc7 )")
bashrc_strings_1+=( ['function __vte_prompt_command']="function $(  declare -pf __vte_prompt_command )")
bashrc_strings_1+=(                   ['function rm']="function $(  declare -pf rm )")
bashrc_strings_2=(                 ['export BROWSER']=$(            declare -p BROWSER ) )
bashrc_strings_2+=(                 ['export EDITOR']=$(            declare -p EDITOR ) )
bashrc_strings_2+=(         ['define PROMPT_COMMAND']=$(            declare -p PROMPT_COMMAND ) )
bashrc_strings_2+=(                    ['export PS0']=$(            declare -p PS0  ) )

  #declare -p files_for_use_with_bash # <>

:;: 'Do some backups'
## Note,  sudo  cannot find  [[  , and  [  requires internal quotes
for VV in "${files_for_use_with_bash[@]}"
do
  : 'File must exist'
  if ! sudo -- [ -f "${VV}" ]
  then
    er_x "line ${nL}, ${VV}"
  fi

  : '...of the array files_for_use_with_bash'
  if ! sudo -- [ -e "${VV}.orig" ]
  then
    sudo -- rsync --checksum --archive -- "${VV}" "${VV}.orig"
    sudo -- chmod 400 -- "${VV}.orig"
    sudo -- chattr +i -- "${VV}.orig"
  fi

  : '...per script-execution'
  ## Note, ~, quoted tildas do not expand
  sudo -- cp --archive -- "${VV}" "${VV}~" || er_x "line ${nL}, ${VV}"
done
unset VV

:;: 'Alter the array files_for_use_with_bash'
write_bashrc_strings "bashrc_strings_1" "bashrc_strings_2"

  #exit $nL # <>

## Clean up from section Bash
unset files_for_use_with_bash bashrc_strings_1 bashrc_strings_2
unset -f write_bashrc_strings

  #EC=101 LL="$nL" exit # <>
  #set -x # <>
  #set +e # <>

:;: 'Vim'

: 'Heredoc of vim-conf-text'
cat <<- \EOF | tee -- "${tmpd}/vim-conf-text" > /dev/null
	" ~/.vimrc

	" per Google
	set number

	" per https://stackoverflow.com/questions/234564/tab-key-4-spaces-and-auto-indent-after-curly-braces-in-vim
	filetype plugin indent on
	" show existing tab with 2 spaces width
	set tabstop=2
	" when indenting with '>', use 2 spaces width
	set shiftwidth=2
	" On pressing tab, insert 2 spaces
	set expandtab

	" per https://superuser.com/questions/286290/is-there-any-way-to-hook-saving-in-vim-up-to-commiting-in-git
  autocmd BufWritePost * execute '! if [[ -d .git ]]; then git commit -S -a -F -; fi'

EOF

  #set -x # <>

: $'Get an array of the FS location\x28s\x29 of root\x27s vimrc\x28s\x29'
readarray -d '' -t arr_vrc < <( sudo -- find /root -name '*vimrc*' -print0 )

case "${#arr_vrc[@]}" in
  0 )
      strng_vrc=/root/.vimrc
    ;;\
  1 )
      strng_vrc="${arr_vrc[*]:=/root/.vimrc}"
    ;;\
  *)
      printf '\n  Multiple .vimrc files found, please edit the filesystem.\n'
      printf '\t%s\n' "${arr_vrc[@]}"
      printf '\n'
    ;;\
esac

  #exit $nL # <>

if (( "${#arr_vrc[@]}" == 1 ))
then
  read -r WW XX < <( sudo -- sha256sum -- "${tmpd}/vim-conf-text" 2>&1 )
  read -r YY XX < <( sudo -- sha256sum -- "${strng_vrc}" 2>&1 )
else
  sudo -- touch -- "${strng_vrc}" # <> set-e
fi

: 'Write .vimrc'
if (( ${#arr_vrc[@]} == 0 )) || ! [[ ${WW} = "${YY}" ]]
then
  : $'Test returned \x22true,\x22 the number didn\x27t match, so write to .vimrc'

  : 'Set the umask'
  read -ra umask_prior < <( umask -p )
  umask 177

  : 'Write the root file'
  sudo -- rsync --archive --checksum -- "${tmpd}/vim-conf-text" "${strng_vrc}" || er_x "${nL}"

  : $'Copy the root file to ~liveuser and repair DAC\x27s on liveuser\x27s copy'
  sudo -- rsync --archive --checksum -- "${strng_vrc}" "/home/${USER}/.vimrc" || er_x "${nL}"
  sudo -- chown "${UID}:${UID}" -- "/home/${USER}/.vimrc"
  chmod 0400 -- "/home/${USER}/.vimrc"

  : 'Reset the umask'
  builtin "${umask_prior[@]}"
fi

## Clean up after section Vim
command -- rm --one-file-system --preserve-root=all --force -- "${tmpd}/vim-conf-text"
unset arr_vrc strng_vrc write2fs WW XX YY umask_prior

  #EC=101 LL="$nL" exit # <>
  #set -x # <>

:;: 'Disk space, increase available by removing non-local locales'

## Note, such as...   /usr/lib/locale /usr/share/i18n/locales /usr/share/locale /usr/share/X11/locale , etc.
## Note, for $dirs1 , find  syntax based on Mascheck's
## Note, for $dirs2 , use of bit bucket because GVFS ‘/run/user/1000/doc’ cannot be read, even by root
## Note, for $fsos3 , '--and' is not POSIX compliant
## Note, for $fsos4 , sorts by unique inode and delimits by nulls

## Bug, Hardcoded path, for $dirs2 , '/run/media/root' is a default for mounting external media on
#+  Fedora-like systems

declare -A fsos5
readarray -d '' -t dirs1 < <( find / ! -path / -prune -type d -print0 )

  #declare -p dirs1 # <>

readarray -d '' -t dirs2 < <(
  find "${dirs1[@]}" -type d -name '*locale*' ! -ipath '*/run/media/root/*' -print0 2> /dev/null )

  #declare -p dirs2 # <>

readarray -d '' -t fsos3 < <(
  find "${dirs2[@]}" -type f -size +2048b '(' ! -ipath '*en_*' -a !  -ipath '*/.git/*' ')' -print0 )

  #declare -p fsos3 # <>

if (( ${#fsos3[@]} > 0 ))
then
  ## Note, for loop is run in a subshell, so unsetting ZZ is unnecessary
  readarray -d '' -t fsos4 < <( {
    for ZZ in "${fsos3[@]}"
    do
      printf '%s\0' "$( stat --printf='%i %n\n' -- "${ZZ}" )"
    done ; } |
      sort --unique |
      tr --delete '\n'
    )

    #declare -p fsos4 # <>

  ## Question, does this assoc array fsos5 need to be declared as such? (I don't think so, but...)

  set -- "${fsos4[@]}"

  while true
  do
    [[ -z ${1:-} ]] && break 1 # <> set-u

    # shellcheck disable=SC2190
    fsos5+=( "${1%% *}" "${1#* }")
    shift 1

    (( $# == 0 )) && break 1
  done
fi

  #declare -p fsos5 # <>

: 'If any larger local data files were found, then remove them interactively'
if [[ -n ${!fsos5[*]} ]]
then
  : 'Inform user of any found FSOs'
  printf '  Script, delete these files? \n'
  declare -p fsos5
  sleep 3

  for AA in "${!fsos5[@]}"
  do
    HH=0
    II=0
    JJ="${fsos5[$AA]#.}"
    printf '  File %d, \n' $(( ++II ))

    while true
    do
      if [[ -e ${JJ} ]]
      then
        ## Note, '\x60' is a "backtick"
        printf '  Script, output of %b, %s \n' '\x60ls\x60' \
          "$( ls -l --all --human-readable --classify --inode --directory "${JJ}" )"
        read -r -p ' > [yN] ' -t 600 yes_or_no
        yes_or_no="${yes_or_no,,?}"
        yes_or_no="${yes_or_no:=n}"

          #declare -p yes_or_no # <>

        case "${yes_or_no}" in
          0|1)  printf '  Zero and one are ambiguous, please use letters. \n'
                continue 0001
              ;;\
          y|t)  printf '  %s %b %s %s \n' 'Script,' ' \x60rm -i\x60 ' 'requires a typed [yN] response,' \
                  'it defaults to do-not-delete if a user just presses [enter].'

                if sudo -- command rm --one-file-system --preserve-root=all --interactive -- "${JJ}"
                then
                  unset 'fsos5[$AA]'
                  break 00001
                else
                  er_x "${nL}, unknown error"
                fi
              ;;\
          n|f)  printf '  Keeping this file. \n'
                unset 'fsos5[$AA]'
                break 00001
              ;;\
          *)    HH=$(( ++HH )) # <> set-e, can be just  (( HH++ ))  when errexit's off

                if (( HH < 3 ))
                then
                  printf '  Invalid response (%d), please try again. \n' "${HH}"

                else
                  printf '  Keeping this file. \n'
                  unset 'fsos5[$AA]'
                  break 00001
                fi
              ;;\
        esac
      else
        break 0001
      fi
    done
  done
fi

## Clean up from section "Disk space"
unset dirs1 dirs2 fsos3 fsos4 fsos5 AA HH II JJ yes_or_no

  #set -x # <>
  #EC=101 LL="$nL" exit # <>

:;: 'Dnf'

## Bug, there should be a n\eeds-restarting loop between each install/upgrade
## Bug, the --security upgrade should be done rpm by rpm

  : 'Beginning section on DNF' # <>
  pause_to_check "$nL" # <>
  set -x

## Note, CUPS cannot be safely removed; too many dependencies
## Note, For some unknown reason, even when  dnf  doesn't change any programs,  dnf
#+  needs-restarting  decides it needs to restart all available Firefox processes, which crashes all of
#+  my tabs.  (Bug?)  So, I'm adding in a few  rpm -qa | wc -l s to only run  dnf
#+  needs-restarting  in the event that any files on disk may actually have been changed.
## Note, these PE's (for_admin, for_bash, etc.) have been tested and should "disappear" by virtue of
#+  whichever expansion does that, leaving just the regular strings as the elements of the array
## Note, this brace grouping (all together of for_admin, for_bash, etc.) is so that "shellcheck disable" will
#+  apply to the entire block

hash_of_installed_rpms_A=$( rpm --all --query | sha256sum | awk '{ print $1 }' )

## Removals for disk space
rpm_nms_for_removal=( google-noto-sans-cjk-vf-fonts mint-x-icons mint-y-icons transmission )

## Removals for security
#rpm_nms_for_removal+=( claws-mail blueman bluez )

# shellcheck disable=SC2206
{
  rpms=(  ${for_admin:=}        ncdu pwgen )
  rpms+=( ${for_bash:=}         bash bash-completion )
  #rpms+=( ${for_bashdb:=}       bash-devel make autoconf )
  rpms+=( ${for_critical_A:=}   sudo nss openssh chrony dnf gpgme xfce4-terminal )
  rpms+=( ${for_critical_B:=}   NetworkManager NetworkManager-{adsl,bluetooth,libnm,ppp,team,wifi,wwan} )
  #rpms+=( ${for_careful:=}      systemd auditd sssd )
  #rpms+=( ${for_db_ish:=}       libreoffice-calc )
  #rpms+=( ${for_bug_rpts:=}     inxi zsh dash mksh lynx )
  #rpms+=( ${for_char_sets:=}    enca moreutils uchardet )
  rpms+=( ${for_duh:=}          info plocate pdfgrep wdiff )
  rpms+=( ${for_firefox:=}      mozilla-noscript mozilla-privacy-badger mozilla-https-everywhere )
  rpms+=( ${for_fun:=}          angband )
  #rpms+=( ${for_gcov:=}         gcc )
  rpms+=( ${for_git:=}          git gh )
  #rpms+=( ${for_internet:=}     chromium )
  #rpms+=( ${for_later_other:=}  memstomp gdb valgrind memstrack kernelshark )
  #rpms+=( ${for_later_trace:=}  bpftrace python3-ptrace fatrace apitrace x11trace )
  rpms+=( ${for_linting:=}      ShellCheck strace )
  #rpms+=( ${for_mo_linting:=}   kcov shfmt patch ltrace )
  #rpms+=( ${for_lockfile:=}     procmail )
  #rpms+=( ${for_os_dnlds:=}     debian-keyring )
  rpms+=( ${for_strings:=}      binutils )
  #rpms+=( ${for_term_tests:=}   gnome-terminal )
  #rpms+=( ${for_unicode:=}      xterm rxvt-unicode perl-Text-Bidi-urxvt )
  rpms+=( ${for_security:=}     orca protonvpn-cli xsecurelock )
}

:;: 'Start with removing any unnecessary RPMs'

  #pause_to_check "$nL" # <>

if [[ -n ${rpm_nms_for_removal:0:8} ]]
then
  ## Note, this  printf  command uses nulls so that '-e' and '%s.*' will be read as separate indices
  #+  by  readarray
  readarray -d '' -t grep_args < <( printf -- '-e\0%s.*\0' "${rpm_nms_for_removal[@]}" )
  readarray -t removable_rpms < <(
    rpm --all --query | grep --ignore-case --extended-regexp "${grep_args[@]}" )

    declare -p grep_args removable_rpms # <>

  :;: 'Keep a list, just in case an rpm removal accidentally erases something vital'
  if [[ -n ${removable_rpms[*]:0:8} ]]
  then
    for QQ in "${!removable_rpms[@]}"
    do
      #declare -p removable_rpms | tee -- "${tmpd}/removable_rpms.array"

      ## Note,  dnf , do not use [-y|--yes] with this particular command
      if sudo -- nice --adjustment=-20 -- dnf --allowerasing remove -- "${removable_rpms[QQ]}"
      then
        unset 'removable_rpms[QQ]'
      else
        er_x Line "${nL}", "${removable_rpms[QQ]}"
      fi
    done
    unset QQ

    #[[ -f "${tmpd}/removable_rpms.array" ]] &&
      #command rm --one-file-system --preserve-root=all --force -- "${tmpd}/removable_rpms.array" # <>
  fi
fi

  #df --sync --output=fstype,avail,pcent,target -- . # <>

:;: 'Then do a blanket security upgrade'

## Note, the problem with this "blanket security upgrade" is how it includes kernel and firmware. Better to
#+  capture list of rpms in a no-op cmd, filter out impractical (for a LiveUsb) rpms, then upgrade the rest.


  #pause_to_check "$nL" # <>

## Count the original number of rpms installed
mapfile -d '' -t all_installed_rpms < <( rpm -qa 2>/dev/null | awk '{ printf "%s\0", $1 }' )
#count="${#all_installed_rpms[@]}"

## Get full list of rpms to upgrade, in an array; exit on non-zero
mapfile -d '' -t rpms_for_upgrade < <( dnf --assumeno upgrade 2>/dev/null | awk '$2 ~ /x86_64|noarch/ { printf "%s\0", $1 }' )

  echo "count, rpms_for_upgrade, ${#rpms_for_upgrade[@]}"

## For each "original rpm" in the original list
for XX in "${!all_installed_rpms[@]}"; 
do 
  ## Loop A, open
    
  ## Re-run the list, grepping for the "original rpm"
  for YY in "${rpms_for_upgrade[@]}" ; 
  do 
    regexp="^${YY}-[0-9]{,16}(\.[0-9]{,16}){,8}-.*\.fc[0-9]{2,3}\.(noarch|x86-64)"; 
      
    ## If the "original rpm" needs to be upgraded
    if [[ "${all_installed_rpms[XX]}" =~ $regexp ]]; 
    then 
        # <>
        echo "$XX : ${all_installed_rpms[XX]}" ; 
        echo "${all_installed_rpms[XX]}" | grep -cEe "$regexp"
        set -x; 
        [[ "${all_installed_rpms[XX]}" =~ $regexp ]]; 
        echo $?; 
        set -; 
    fi
  done
  unset YY

    pause_to_check "$nL" # <>

  for ZZ in "${rpms_for_upgrade[@]}" ; 
  do 
    regexp="^${ZZ}-[0-9]{,16}(\.[0-9]{,16}){,8}-.*\.fc[0-9]{2,3}\.(noarch|x86-64)"; 

    if [[ "${all_installed_rpms[XX]}" =~ $regexp ]]; 
    then 

      ## then upgrade just that one "original rpm"; exit on non-zero
      sudo -- nice --adjustment=-20 -- dnf --verbose upgrade "$ZZ" || er_x "$nL" "$ZZ"

      ## Run "needs-restarting"
      readarray -t nr_pids < <(\
        sudo -- nice --adjustment=-20 -- dnf --quiet needs-restarting 2>/dev/null | awk '{ print $1 }' )

        declare -p nr_pids # <>
        pause_to_check "$nL" # <>

      ## Restart PIDs as necessary, using multiple signals; exit on non-zero
      for WW in "${nr_pids[@]}"
      do
        sudo -- nice --adjustment=-20 -- "$(type -P kill)" --verbose \
          --timeout 1000 HUP \
          --timeout 1000 USR1 \
          --timeout 1000 TERM \
          --timeout 1000 KILL -- "$WW"
      done
      unset WW

    ## If the "original rpm" is NA in the new list of rpms-to-be-upgraded
    else
      ## then unset the "original rpm" index and continue with the next iteration of Loop A
      unset 'all_installed_rpms[XX]'
    fi; 
  done; 
  unset ZZ
done
unset XX

exit 101





  ## Loop A, shut

## Loop A, end

sudo -- nice --adjustment=-20 -- dnf --assumeyes --security upgrade || er_x "${nL}"

  #df --sync --output=fstype,avail,pcent,target -- . | grep --invert-match ^Type # <>

:;: 'Find out whether an RPM is installed, one by one'

  #pause_to_check "$nL" # <>

for UU in "${!rpms[@]}"
do
  if sudo -- nice --adjustment=-20 -- rpm --query --quiet -- "${rpms[UU]}"
  then
    installed_rpms+=( "${rpms[UU]}" )
    unset 'rpms[UU]'
  fi
done
unset UU

:;: 'Upgrade any installed RPMs from the main list, en masse'

## Note, this section should upgrade rpms one by one

  #pause_to_check "$nL" # <>

if [[ -n ${installed_rpms[*]: -1:1} ]]
then
  sudo -- nice --adjustment=-20 -- dnf --assumeyes --quiet upgrade -- "${installed_rpms[@]}" || er_x "${nL}"
fi

:;: 'Install any as yet uninstalled RPMs from the main list as necessary'

  #pause_to_check "$nL" # <>

uninstalled_rpms=( "${rpms[@]}" )

if [[ -n ${uninstalled_rpms[*]: -1:1} ]]
then
  ## Note, if you install multiple rpms at the same time, and one of them causes some error, then you have
  #+  no immediate way of knowing which one caused the error

  for VV in "${uninstalled_rpms[@]}"
  do
    sudo -- nice --adjustment=-20 -- dnf --assumeyes --quiet install -- "${VV}" || er_x "${nL}"

    readarray -t nr_pids < <(
      sudo -- nice --adjustment=-20 -- dnf --quiet needs-restarting 2> /dev/null | awk '{ print $1 }')

      declare -p nr_pids # <>

    if [[ -n ${nr_pids[*]:0:1} ]]
    then

      for WW in "${nr_pids[@]}"
      do
        ps aux | awk "\$2 ~ /${WW}/ { print }"

        #pause_to_check "$nL"

        sudo -- nice --adjustment=-20 -- "$(type -P kill)" --verbose \
          --timeout 1000 HUP \
          --timeout 1000 USR1 \
          --timeout 1000 TERM \
          --timeout 1000 KILL -- "$WW"

        : 'Now restart some PID ??'

        #pause_to_check "$nL"

      done
      unset WW
    fi
  done
  unset VV
fi
unset rpm_nms_for_removal rpms
unset for_{admin,bash,bashdb,db_ish,bug_rpts,duh,firefox,fun,gcov,git,internet,later_{other,trace}}
unset for_{linting,lockfile,os_dnlds,strings,term_tests,unicode}
unset grep_args removable_rpms rr installed_rpms uninstalled_rpms

  #df --sync --output=fstype,avail,pcent,target -- . | grep --invert-match ^Type # <>
  #EC=101 LL="$nL" exit # <>
  #set -x # <>

:;: 'Restart any processes that may need to be restarted. Begin by getting a list of any such PIDs'

  #pause_to_check "$nL" # <>

a_pids=()
pr_counter=0
get_pids_for_restarting

  #declare -p pr_counter # <>
  #EC=101 LL="$nL" exit # <>

hash_of_installed_rpms_B=$( rpm --all --query | sha256sum | awk '{ print $1 }' )

if ! [[ ${hash_of_installed_rpms_A} = "${hash_of_installed_rpms_B}" ]] || [[ "${#a_pids[@]}" -gt 0 ]]
then
  while true
  do

    ## Note,  [[ ... = , this second test,  [[ ${a_pids[*]} = 1 ]]  is correct; ie, do not use ((...))
    :;: 'if any PID\s were found... ...and if there are any PID\s other than PID 1...'
    if [[ -n ${a_pids[*]: -1:1} ]] && ! [[ ${a_pids[*]} = 1 ]]
    then
      II=0
      XX="${#a_pids[@]}"

      :;: 'Print some info and wait for it to be read'
      ## Note, '\x27' is a single quote
      printf '\n  %b for restarting, count, %d \n\n' 'PID\x27s' "${XX}"

        sleep 1 # <>

      :;: 'for each signal and for each PID...'
      for YY in "${!a_pids[@]}"
      do
        ## Note, readability
        :;: $'\x60kill\x60 '"loop $(( ++II )) of ${XX}" ;:

        ZZ="${a_pids[YY]}"
        (( ZZ == 1 )) && continue 001
        sleep 1

          #pause_to_check "$nL" # <>

        for AA in HUP USR1 TERM KILL
        do

            : "To kill PID $ZZ with signal $AA" # <>
            #pause_to_check "$nL" # <>

          #sleep 1
          sync --file-system

            wait -f # <>

          :;: '...if the PID is still running...'
          if ps --no-headers --quick-pid "${ZZ}"
          then

            :;: '...then \kill\ it with the according per-loop SIGNAL...'
            ## Note, the exit codes for  kill  only indicate whether or not the target PIDs existed, rather
            #+ than whether the  kill  operation succeeded, per  info kill .
            sudo -- "$(type -P kill)" --signal "${AA}" -- "${ZZ}"

            :;: '...and if the PID in question no longer exists then unset the current array index number'
            if ps --no-headers --quick-pid "${ZZ}"
            then
              is_zombie=$( ps aux | awk "\$2 ~ /${ZZ}/ { print \$8 }" )

              if [[ ${is_zombie} = 'Z' ]]
              then
                : 'Process is a zombie; unsetting'
                unset 'a_pids[YY]'
                break 00001
              else
                continue 00001
              fi
            else
              unset 'a_pids[YY]'
              break 0001
            fi
          else
            unset 'a_pids[YY]'
            break 001
          fi
        done
        unset AA
      done
      unset YY ZZ
    else
      break 1
    fi
  done
  unset II XX a_pids is_zombie
fi

  #EC=101 LL="$nL" exit # <>
  #set -x # <>

:;: 'Restart NetworkManager if necessary'

  #pause_to_check "$nL" # <>

## TODO: use written function here
for BB in "${dns_srv_A}" "${dns_srv_1}"
do
  if ! ping -4qc1 -- "${BB}" > /dev/null 2>&1
  then
    sudo -- nice --adjustment=-20 -- systemctl restart -- NetworkManager.service || er_x "${nL}"
  fi
done
unset BB

# <Logs> Write to TTY and exit
#"$(type -P kill)" --signal USR2 -- "$$" # <Logs>

printf '  %s - Done \n' "$( date +%H:%M:%S )"
EC='00' LL="$nL" exit

