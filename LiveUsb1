#!/bin/bash
## LiveUsb1
  # shellcheck disable=SC2206,SC2317,SC2312

## TODO: make re-entrant: add atomicity to all changes
## TODO: add function boundary comments to all functions that will be used in-script. Functions that will 
#+  only be written out to files do not need any such comments. 

## Note: Online Git book:
#+  https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository
## Note: Idempotent script
## Note: style / function definition syntax: '(){ :' makes plain xtrace easier to read

## Bug: this kill loop usually kills the user session, including the terminal and the script, so the script
#+  usually needs to be run multiple times. (search: /Restart any processes )

# <> Debugging
set -aCuTeo pipefail # <>

umask 077
hash -r

fn_bndry=' ~~~ ~~~ ~~~ '
fn_lvl=0
scr_nm=LiveUsb1

: 'Functions TOC...'
  ## functions_this_script=( 
  #+	'__vte_osc7()'
  #+	'__vte_prompt_command()'
  #+	'er_x()'
  #+	'get_pids_for_restarting()'
  #+	'must_be_root()'
  #+	'rm()'
  #+	'test_dns()'
  #+  'trap_exit()'
  #+	'write_bashrc_strings()'
  #+)
functions_for_appending_into_bashrc=(
  '__vte_osc7'
  '__vte_prompt_command'
  'rm'
  ) 
: 'redefine all functions to be appended into bashrc'
for uu in "${functions_for_appending_into_bashrc[@]}"
do 
  unset -f "$uu"
done
unset uu

function __vte_osc7(){ \
  local - cmd urlencode_o
  cmd=$( PATH="${PATH}:/usr/libexec:/usr/lib:/usr/lib64" command -v vte-urlencode-cwd )
  [[ -n ${cmd} ]] || return
  urlencode_o=$( "${cmd}" )
  ## Bug: what does this \x60printf\x60 actually do???
  printf '\033]7;file://%s%s\033' "${HOSTNAME}" "${urlencode_o:-"${PWD}"}"
}

function __vte_prompt_command(){ \
  local - prompt_cmd pwd
  prompt_cmd=$( HISTTIMEFORMAT='' history 1 | sed 's/^ *[0-9]\+ *//' ) prompt_cmd="${prompt_cmd//;/ }"
  pwd=~

  if ! [[ ${PWD} = ~ ]]
  then
    pwd="${PWD/#"${HOME}"\//\~\/}" pwd="${pwd//[[:cntrl:]]}"
  fi
  
  ## Bug: what does this \x60printf\x60 actually do???
  printf '\033[m\033]7;%s@%s:%s\033' "${USER}" "${HOSTNAME%%.*}" "${pwd}"
  __vte_osc7
}

function er_x(){ \
  local - exit_code="$?" _="${fn_bndry} er_x() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  
  printf '%s: Error: %s\n' "$scr_nm" "$*" >&2
  
  true "${fn_bndry} er_x() ENDS ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
  exit "${exit_code}"
} 

  # shellcheck disable=SC2034 # (warning): pipeline1 appears unused

function get_pids_for_restarting(){ \
  local - dnf_o pipeline1 pipeline2

  ## Note: \x60local -Ig\x60 picks up attributes and values from global scope and also outputs same to global scope. ?!

  local -Ig a_pids pr_counter
  dnf_o=$( sudo -- nice --adjustment=-20 -- dnf needs-restarting 2> /dev/null || er_x "${nL}" )

  ## Note: this pipeline was broken out into its constituent commands in order to verify the values mid-stream

  pipline1=$( awk '{ print $1 }' <<< "${dnf_o}" )
  pipline2=$( grep --only-matching --extended-regexp ^'[0-9]*'$ <<< "${pipline1}" )
  
  readarray -d '' -t a_pids < <( tr '\n' '\0' <<< "${pipline2}" )

  : 'lengths of variables'
  : $(( ++pr_counter ))
  : Lengths of vars, measurement no.: "${pr_counter}"
  : dnf_o:    "${#dnf_o}"
  : pipline1: "${#pipline1}"
  : pipline2: "${#pipline2}"
  : a_pids:   "${#a_pids}"
}

function must_be_root(){ \
  local -
  set -
  if [[ ${UID} = 0 ]]
  then
    er_x Must be a regular user and use sudo
  else
    sudo --validate || er_x "${nL}"
  fi
}

## Note: rm(): command shadowing is intended in this case

function rm(){ \
  [[ ${#@} -eq 0 ]] && return 1
  
  local - delete_d fd time_sfx opts_done
  delete_d=~/rm.d 
  time_sfx=$( date --utc +%s ) 

  if ! [[ -e ${delete_d} ]]
  then
    mkdir --mode 0700 --verbose -- "${delete_d}" || return 2
  fi

  for fd
  do
    if [[ ${opts_done} = yes ]]
    then
      
      if [[ -e ${fd} ]]
      then

        ## Note: \x60mv\x60 is commonly a default alias

        command mv --backup --suffix="${time_sfx}" -- "${fd}" "${delete_d}" || return 3
      fi
    else
      
      if [[ $fd = '--' ]] 
      then
        opts_done=yes
      else
        shift 
        continue
      fi
    fi
    [[ -z ${opts_done} ]] && er_x "${nL}"
  done
}

function test_dns(){ \
  local -
  set -
  sudo -- ping -c 1 -W 15 -- "$1" > /dev/null 2>&1
}

function trap_exit(){ local - exit_trap_ec="${ec:-$?}" lineno="${nn:-$nL}"
  set -
  if [[ -e ${tmpd} ]]
  then
    command rm --one-file-system --preserve-root=all --force --recursive -- "${tmpd}"
  fi
  trap - EXIT
  if [[ $exit_trap_ec = "00" ]]
  then
    : "End of script, line:${lineno}"
  else
    : "End of EXIT trap"
  fi
  builtin exit "${exit_trap_ec}"
}

function write_bashrc_strings(){ :
  local - file_x Aa_index Aa_element
  local -n nr="$1"

    set -x # <>

  : 'For each .bashrc'
  for file_x in "${files_for_use_with_bash[@]}"
  do
    : 'For each definition'
    for Aa_index in "${!nr[@]}"
    do
      : 'If the definition is not yet written into the file'
      if ! sudo -- grep --quiet --fixed-strings --regexp="## ${Aa_index}" -- "${file_x}"
      then

        ## Note: use \x60unset\x60 so that values from previous loops will not interfere with the current loop

        Aa_element="${nr[${Aa_index}]}"
        
        : 'Then write the definition into the file, and if the write fails, exit print the line number to xtrace'
        printf '\n## %s \n%s \n' "${Aa_index}" "${Aa_element}" | 
          sudo -- tee --append -- "${file_x}" > /dev/null || er_x "${nL}"
      fi
    done

    : 'For each file, if absent add a newline at EOF'
    if sudo -- tail --lines 1 -- "${file_x}" | grep --quiet --extended-regexp '[[:graph:]]'
    then
      printf '\n' | 
        sudo -- tee --append -- "${file_x}" > /dev/null
    fi
  done
}

: 'Test OS'
## Note: written for Fedora: see hardcoded /run/media/root'
## Note: test of $kernel_release is a test for whether the OS is Fedora (ie, "fc38" or "Fedora Core 38")
kernel_release=$( uname -r )
if ! [[ ${kernel_release} =~ \.fc[0-9]{2}\. ]] 
then
  er_x "${LINENO}: OS is not Fedora"
fi
unset kernel_release

: 'Write to TTY'
tt=$( date +%H:%M:%S )
printf '  %s - Executing %s \n' "${tt}" "$0"
unset tt

: 'Error handling, variables and functions'

## Bug: only way to export namerefs? 
## Note: variable assignments: Backslash escape bc \x60sed -i\x60
  # shellcheck disable=SC1001 # (info): This \I will be a regular 'I' in this context.

declare -nx nL=L\INENO

: 'PATH'
PATH='/usr/bin:/usr/sbin' export PATH

: 'Working dir'
tmpd=$( TMPDIR='' mktemp --directory --suffix=-scf 2>&1 || er_x "${nL}" )
[[ -d ${tmpd} ]] || er_x "${nL}"

: 'trap on EXIT'

## Bug: these var assignments $exit_trap_ec and $lineno only fail when they're on line number >=2 of \x60trap\x60 "args section" ??
  # shellcheck disable=SC2154 #(warning): ec|exit_trap_ec|lineno|nn is referenced but not assigned.

trap trap_exit EXIT

: 'Other environment variables'
LC_ALL=''
PS1=''

: 'Initialize some env vars found in sourced files, as a workaround for nounset'
## Note, local style: inline comments, ie, 'echo foo ## Note: blah', are useful for rebutting false positives from ShellCheck 
# shellcheck disable=SC2034 #(warning): BASHRCSOURCED appears unused. Verify use (or export if used externally).
declare BASHRCSOURCED USER_LS_COLORS ## Note: /etc/bashrc and /etc/profile.d/colorls.*sh on Fedora 38

# <Logs>
#exec 3>&1 4>&2 # <Logs>
#trap 'set - ; exec 2>&4 1>&3' EXIT HUP INT QUIT USR2 TERM # <Logs>
#exec 1> ./Log_begin-1.txt 2>&1 # <Logs>

: 'Regular users with sudo, only'
must_be_root

: 'Certain files must have been installed from off-disk'
files_for_use_with_github=( ~/.ssh ~/.gnupg ~/.config/gh ~/.config/toprc ~/.vimrc ) 

  #files_for_use_with_github+=( ~/.foo) # <>

for ff in "${files_for_use_with_github[@]}"
do
  if ! [[ -e ${ff} ]]
  then
    er_x "${nL}", "${ff}"
  fi
done
unset ff

: 'Network'
## Note: 1 is Google; A is Comcast
dns_srv_1=8.8.8.8
dns_srv_A=75.75.75.75

## Note: \x60ping\x60 doesn't have long options
  # shellcheck disable=SC2310 # (info): This function is invoked in a ! condition so set -e will be disabled.

if ! test_dns "${dns_srv_1}" || ! test_dns "${dns_srv_A}"
then
  printf '\n%s: Attempting to connect to the internet... \n\n' "$scr_nm"

  ## Note: \x60systemctl start\x60 appears to be idempotent

  : 'Try to get NetworkManager up and running'
  sudo -- nice --adjustment=-20 -- systemctl start -- NetworkManager.service
  wait -f

  : 'Turn on networking'
  sudo -- nmcli n on

  : 'Turn on WiFi'
  sudo -- nmcli r wifi on

  : 'Get interface name(s)'
  readarray -d '' -t ifaces < <( nmcli --terse c | awk -F: '$1 !~ /lo/ { printf "%s\0", $1 }' )

  : 'Connect the interface'
  case "${#ifaces[@]}" in
    0 ) 
      er_x "line:${nL}, No network device available"
      ;;#
    1 ) 
      nmcli c up "${ifaces[*]}"
      sleep 5
      ;;#
    * )
      er_x "line:${nL}, Multiple network devices available"
      ;;#
  esac

    # shellcheck disable=SC2310

  if ! test_dns "${dns_srv_1}" || ! test_dns "${dns_srv_A}"
  then
    printf '\n%s: Network: Giving up; exiting.\n\n' "$scr_nm"
  else
    printf '\n%s: Network: Success! \n\n' "$scr_nm"
  fi
fi

## Clean up from Network
## Note: dns_srv_A will be used at the end of the script
unset -f test_dns

: 'Time'
sudo -- timedatectl set-local-rtc 0
sudo -- timedatectl set-timezone America/Vancouver
sudo -- nice --adjustment=-20 -- systemctl start chronyd.service || er_x "line:${nL}"
sudo -- chronyc makestep > /dev/null

  #ec=101 nn="$nL" exit # <>
  #set -x # <>

: 'Bash'
## Note: this section is for .bashrc. VTE functions are from Fedora 38, Sun 09 July 2023, altered from vte.sh
## Note: \x60set [-|-x]\x60: letting xtrace expand this \x60tput\x60 command alters all xtrace colorization

: 'Env vars for bashrc'

: 'Color code assigned to PS0, ducking xtrace'
if [[ -o xtrace ]]
then
  set -
  PS0=$( tput setaf 43 )
  set -x
else
  PS0=$( tput setaf 43 )
fi
PS1="[\\u@\\h]\\\$ "
PROMPT_COMMAND=( [0]="printf '%b' '\\033[m'" [1]="__vte_prompt_command" )
BROWSER=$( command -v firefox )
EDITOR=$( command -v vim )

## Note, TERM_SESSION_ID, 1: added in order to identify which TTY is using which terminal emulator program. See 
#+  also: https://stackoverflow.com/questions/42710685/bash-identify-a-terminal-session

#TERM_SESSION_ID="${TERM_SESSION_ID:-}"
#if [[ -z "$TERM_SESSION_ID" ]] 
#then
  #TERM_SESSION_ID=$( uuidgen )
  #export TERM_SESSION_ID
#fi

declare -A bashrc_strings_1 bashrc_strings_2
files_for_use_with_bash=( /root/.bashrc ~/.bashrc )
missing_fns=()

: 'Append user variables and functions into .bashrc.'
## Note: these arrays include some command substitutions which depend on some function definitions, which in
#+ turn must be defined prior to defining these arrays
for nn in "${functions_for_appending_into_bashrc[@]}"
do
  if [[ $( declare -pF ${nn} 2>&1 ) =~ 'not found' ]]
  then
    missing_fns+=( "${nn}" )
  fi
done
unset nn

if [[ ${#missing_fns[@]} -gt 0 ]]
then
  er_x "${nL}", "${missing_fns[@]}"
fi


# shellcheck disable=SC2034,SC2016
bashrc_strings_1=(               ['function __vte_osc7']="function $( declare -pf __vte_osc7              )")
bashrc_strings_1+=(    ['function __vte_prompt_command']="function $( declare -pf __vte_prompt_command    )")

# shellcheck disable=SC2016
bashrc_strings_2=(   ['export "${bashrc_strings_2[@]}"']=$(           declare -p BROWSER EDITOR           ) )
# shellcheck disable=SC2016
bashrc_strings_2+=(  ['export "${bashrc_strings_2[@]}"']=$(           declare -p PROMPT_COMMAND PS0       ) )
bashrc_strings_2+=(                      ['function rm']="function $( declare -pf rm                      )")

: 'Do some backups'
for ff in "${files_for_use_with_bash[@]}"
do
  : '...of the array files_for_use_with_bash'

  ## Note:  sudo  cannot find  [[  and  [  requires quotes internally

  if ! sudo -- [ -e "${ff}.orig" ]
  then
    if [[ -f ${ff} ]]
    then
      sudo -- rsync --checksum --archive -- "${ff}" "${ff}.orig"
      sudo -- chmod 400 -- "${ff}.orig"
      sudo -- chattr +i -- "${ff}.orig"
    else
      er_x "line:${nL}, ${ff}"
    fi
  fi

  : '...per script-execution'

  ## Note: quoted tildas do not expand

  sudo -- cp --archive -- "${ff}" "${ff}~" || er_x "line:${nL}, ${ff}"
done

: 'Alter the array files_for_use_with_bash'
write_bashrc_strings "bashrc_strings_1"
write_bashrc_strings "bashrc_strings_2"

## Clean up from section Bash
unset files_for_use_with_bash bashrc_strings_1 bashrc_strings_2
unset -f write_bashrc_strings

  #ec=101 nn="$nL" exit # <>
  #set -x # <>
  #set +e # <>

: 'Vim'

## Bug: hardcoded filename, 'vim-conf-text'

: 'Heredoc of vim-conf-text'
cat <<- \EOF | tee -- "${tmpd}/vim-conf-text" > /dev/null
	" ~/.vimrc

	" per Google
	set number

	" per https://stackoverflow.com/questions/234564/tab-key-4-spaces-and-auto-indent-after-curly-braces-in-vim
	filetype plugin indent on
	" show existing tab with 2 spaces width
	set tabstop=2
	" when indenting with '>', use 2 spaces width
	set shiftwidth=2
	" On pressing tab, insert 2 spaces
	set expandtab

	" per https://superuser.com/questions/286290/is-there-any-way-to-hook-saving-in-vim-up-to-commiting-in-git ...and then some guessing and testing :-( 
  autocmd BufWritePost * execute '! if [[ -d .git ]] || git rev-parse --git-dir > /dev/null 2>&1 ; then git commit --gpg-sign --all --file - ; fi'

EOF

: $'Get an array of the FS location\x28s\x29 of root\x27s vimrc\x28s\x29' 

readarray -d '' -t arr_vrc < <( sudo -- find /root -name '*vimrc*' -print0 )

case "${#arr_vrc[@]}" in
  0|1)

      ## Bug? hardcoded conf file pathname

      strng_vrc="${arr_vrc[*]:=/root/.vimrc}"
      write2fs=yes

      if (( "${#arr_vrc[@]}" == 1 ))
      then
        read -r aa bb cc ff < <( sudo -- wc -- "${tmpd}/vim-conf-text" 2>&1 )
        read -r xx yy zz ff < <( sudo -- wc -- "${strng_vrc}" 2>&1 )
      else
        sudo -- touch -- "${strng_vrc}" # <> set-e
      fi
    ;;#
  *)
      printf '  Multiple .vimrc files found: please edit the filesystem. \n'
      printf '%s \n' "${arr_vrc[@]}"
    ;;#
esac

: 'Write .vimrc'
if [[ ${write2fs} = yes ]]
then
  if (( ${#arr_vrc[@]} == 0 )) || ! [[ ${aa},${bb},${cc} = "${xx},${yy},${zz}" ]]
  then
    : $'Test returned \x22true,\x22 the number didnt match, so write to .vimrc'

    : 'Set the umask and write the root file'
    read -ra umask_prior < <( umask -p )
    umask 177

    sudo -- rsync --archive --checksum -- "${tmpd}/vim-conf-text" "${strng_vrc}" || er_x "${nL}"

    : $'Copy the root file to ~liveuser and repair DAC\x27s on liveuser\x27s copy'
    sudo -- rsync --checksum --archive -- "${strng_vrc}" "/home/${USER}/.vimrc" || er_x "${nL}"
    sudo -- chown "${UID}:${UID}" -- "/home/${USER}/.vimrc"
    chmod 0400 -- "/home/${USER}/.vimrc"

    : 'Reset the umask'
    builtin "${umask_prior[@]}"
  fi
fi

## Clean up after section Vim
command -- rm --one-file-system --preserve-root=all --force -- "${tmpd}/vim-conf-text"
unset arr_vrc strng_vrc write2fs aa bb cc ff xx yy zz umask_prior

  #ec=101 nn="$nL" exit # <>
  #set -x # <>

: 'Disk space: increase available by removing non-local locales'

## Note: such as... /usr/lib/locale /usr/share/i18n/locales /usr/share/locale /usr/share/X11/locale , etc.
## Note: for $dirs1 , \x60find\x60 syntax based on Mascheck's
## Note: for $dirs2 , use of bit bucket because GVFS ‘/run/user/1000/doc’ cannot be read, even by root
## Note: for $fsos3 , '--and' is not POSIX compliant
## Note: for $fsos4 , sorts by unique inode and delimits by nulls

## Bug: Hardcoded path, for $dirs2 , '/run/media/root' is a default for mounting external media on Fedora-like systems

declare -A fsos5
readarray -d '' -t dirs1 < <( find / ! -path / -prune -type d -print0 )

  #declare -p dirs1 # <>

readarray -d '' -t dirs2 < <( find "${dirs1[@]}" -type d -name '*locale*' ! -ipath '*/run/media/root/*' -print0 2> /dev/null ) 

  #declare -p dirs2 # <>

readarray -d '' -t fsos3 < <( find "${dirs2[@]}" -type f -size +2048b '(' ! -ipath '*en_*' -a !  -ipath '*/.git/*' ')' -print0 )

  #declare -p fsos3 # <>

if [[ ${#fsos3[@]} -gt 0 ]]
then
  readarray -d '' -t fsos4 < <( {
    for ff in "${fsos3[@]}" ; do
      printf '%s\0' "$( stat --printf='%i %n\n' -- "${ff}" )"
    done ; } |
      sort --unique |
      tr --delete '\n' 
    )

  ## Question: does this assoc array fsos5 need to be declared as such? (I don't think so, but...)

    #declare -p fsos4 # <>

  set -- "${fsos4[@]}"
  
  while true
  do
    [[ -z ${1:-} ]] && break 1 # <> set-u

      # shellcheck disable=SC2190 # (warning): Elements in associative arrays need index

    fsos5+=( "${1%% *}" "${1#* }")
    shift 1
    
    [[ $# -eq 0 ]] && break 1
  done
fi

  #declare -p fsos5 # <>

: 'If any larger local data files were found, then remove them interactively'
if [[ -n ${!fsos5[*]} ]]
then
  : 'Inform user of any found FSOs'
  printf '  Script: delete these files? \n'
  #declare -p fsos5
  sleep 3

  for dd in "${!fsos5[@]}"
  do
    mm=0
    tt=0
    xx="${fsos5[$dd]#.}"
    printf '  File %d: \n' $(( ++mm ))

    while true
    do
      if [[ -e ${xx} ]]
      then

        ## Note: '\x60' is a "backtick"

        printf '  Script, output of %b: %s \n' '\x60ls\x60' \
          "$( ls -l --all --human-readable --classify --inode --directory "${xx}" )"
        #read -r -n 1 -p ' > [yN] ' -t 60 yn
        read -r -p ' > [yN] ' -t 60 yn
        yn="${yn,,?}"
        yn="${yn:=n}"

          #declare -p yn # <>

        case "${yn}" in
          0|1)  printf '  Zero and one are ambiguous: please use letters. \n'
                continue 0001
              ;;#
          y|t)  printf '  %s %b %s %s \n' 'Script:' ' \x60rm -i\x60 ' 'requires a typed [yN] response:' \
                  'it defaults to do-not-delete if a user just presses [enter].'

                  # shellcheck disable=SC2310 # (info): This function is invoked in an 'if' condition so set -e...

                if sudo -- command rm --one-file-system --preserve-root=all --interactive -- "${xx}"
                then
                  unset 'fsos5[$dd]'
                  break 00001
                else
                  er_x "${nL}, unknown error"
                fi
              ;;#
          n|f)  printf '  Keeping this file. \n'
                unset 'fsos5[$dd]'
                break 00001
              ;;#
          *)    tt=$(( ++tt )) # <> set-e: can be just \x60(( tt++ ))\x60 when errexit's off

                if (( tt < 3 ))
                then
                  printf '  Invalid response (%d): please try again. \n' "${tt}"

                else
                  printf '  Keeping this file. \n'
                  unset 'fsos5[$dd]'
                  break 00001
                fi
              ;;#
        esac
      else
        break 0001
      fi
    done
  done
fi

## Clean up from section "Disk space"
unset dirs1 dirs2 fsos3 fsos4 fsos5 dd mm tt xx yn

  #set -x # <>
  #ec=101 nn="$nL" exit # <>

: 'Dnf'
## Note: CUPS cannot be safely removed; too many dependencies
## Note: For some unknown reason, even when \x60dnf\x60 doesn't change any programs, \x60dnf 
#+  needs-restarting\x60 decides it needs to restart all available Firefox processes, which crashes all of 
#+  my tabs.  :-(  (Bug?)  So, I'm adding in a few \x60rpm -qa | wc -l\x60s to only run \x60dnf 
#+  needs-restarting\x60 in the event that any files on disk may actually have been changed.

rpm_count_A=$( rpm -qa | sha256sum | awk '{ print $1 }' )

## Note: these PE's have been tested and should "disappear" by virtue of whichever expansion does that, leaving
#+  just the regular strings as the elements of the array
rpm_nms_for_removal=( google-noto-sans-cjk-vf-fonts mint-x-icons mint-y-icons transmission )
  # shellcheck disable=SC2086 #(info): Double quote to prevent globbing...

rpms=(  ${for_admin:=}        ncdu pwgen )
rpms+=( ${for_bash:=}         bash bash-completion )
rpms+=( ${for_bashdb:=}       bash-devel make autoconf )
#rpms+=( ${for_db_ish:=}       libreoffice-calc )
rpms+=( ${for_bug_rpts:=}     inxi zsh dash mksh lynx )
rpms+=( ${for_char_sets:=}    enca moreutils uchardet )
rpms+=( ${for_duh:=}          info pdfgrep wdiff )
rpms+=( ${for_firefox:=}      mozilla-noscript mozilla-privacy-badger mozilla-https-everywhere )
rpms+=( ${for_fun:=}          angband )
#rpms+=( ${for_gcov:=}         gcc )
rpms+=( ${for_git:=}          git gh )
#rpms+=( ${for_internet:=}     chromium )
#rpms+=( ${for_later_other:=}  memstomp gdb valgrind memstrack kernelshark )
#rpms+=( ${for_later_trace:=}  bpftrace python3-ptrace fatrace apitrace x11trace )
rpms+=( ${for_linting:=}      ShellCheck kcov shfmt patch strace ltrace )
rpms+=( ${for_lockfile:=}     procmail )
#rpms+=( ${for_os_dnlds:=}     debian-keyring )
rpms+=( ${for_strings:=}      binutils )
rpms+=( ${for_term_tests:=}   gnome-terminal )
rpms+=( ${for_unicode:=}      xterm rxvt-unicode perl-Text-Bidi-urxvt )
rpms+=( ${for_security:=}     orca protonvpn-cli )

: 'Start with removing any unnecessary RPMs'

  # shellcheck disable=SC2034 # (warning): nm appears unused.

if [[ -n ${rpm_nms_for_removal:0:8} ]]
then
  readarray -d '' -t grep_args < <( printf -- '-e\0%s.*\0' "${rpm_nms_for_removal[@]}" )
  readarray -t removable_rpms < <( rpm -qa | grep --ignore-case --extended-regexp "${grep_args[@]}" )

    #declare -p grep_args removable_rpms # <>

  : 'Keep a list, just in case an rpm removal accidentally erases something vital'
  if [[ -n ${removable_rpms[*]:0:8} ]]
  then
    for rr in "${!removable_rpms[@]}"
    do
      #declare -p removable_rpms | tee -- "${tmpd}/removable_rpms.array"

      ## Note: \x60dnf\x60: do not use [-y|--yes] with this command 

      if sudo -- nice --adjustment=-20 -- dnf --allowerasing remove -- "${removable_rpms[rr]}"
      then
        unset 'rpm_nms_for_removal[nm]'
      else
        er_x Line:"${nL}", "${removable_rpms[rr]}"
      fi
    done

    command rm --one-file-system --preserve-root=all --force -- "${tmpd}/removable_rpms.array"
  fi
fi

  #df --sync --output=fstype,avail,pcent,target -- . # <>

: 'Then do a blanket security upgrade'
sudo -- nice --adjustment=-20 -- dnf --assumeyes --quiet --security upgrade || er_x "${nL}"

  #df --sync --output=fstype,avail,pcent,target -- . | grep --invert-match ^Type # <>

: 'Find out whether an RPM is installed, one by one'
for rr in "${!rpms[@]}"
do
  if sudo -- nice --adjustment=-20 -- rpm --query --quiet -- "${rpms[rr]}"
  then
    installed_rpms+=( "${rpms[rr]}" )
    unset 'rpms[rr]'
  fi
done

: 'Upgrade any installed RPMs from the main list, en masse'
if [[ -n ${installed_rpms[*]: -1:1} ]]
then
  sudo -- nice --adjustment=-20 -- dnf --assumeyes --quiet upgrade -- "${installed_rpms[@]}" || er_x "${nL}"
fi

: 'Install any as yet uninstalled RPMs from the main list as necessary'
uninstalled_rpms=( "${rpms[@]}" )

if [[ -n ${uninstalled_rpms[*]: -1:1} ]]
then
  sudo -- nice --adjustment=-20 -- dnf --assumeyes --quiet install -- "${uninstalled_rpms[@]}" || 
    er_x "${nL}"
fi
unset rpm_nms_for_removal rpms
unset for_{admin,bash,bashdb,db_ish,bug_rpts,duh,firefox,fun,gcov,git,internet,later_{other,trace},linting,lockfile,os_dnlds,strings,term_tests,unicode}
unset grep_args removable_rpms rr installed_rpms uninstalled_rpms

  #df --sync --output=fstype,avail,pcent,target -- . | grep --invert-match ^Type # <>
  #ec=101 nn="$nL" exit # <>
  #set -x # <>

: 'Restart any processes that may need to be restarted. Begin by getting a list of any such PIDs'

a_pids=()
pr_counter=0

  #declare -p pr_counter # <>
  #ec=101 nn="$nL" exit # <>

rpm_count_B=$( rpm -qa | sha256sum | awk '{ print $1 }' )

if ! [[ ${rpm_count_A} = "${rpm_count_B}" ]]
then
  while true
  do
    get_pids_for_restarting

    ## Note: \x60[[ ... =\x60: this second test, \x22[[ ${a_pids[*]} = 1 ]]\x22 is correct
    : 'if any PID\s were found... ...and if there are any PID\s other than PID 1...'
    if [[ -n ${a_pids[*]: -1:1} ]] && ! [[ ${a_pids[*]} = 1 ]]
    then
      ii=0
      nn="${#a_pids[@]}"

      : 'Print some info and wait for it to be read'

      ## Note: '\x27' is a single quote

      printf '\n  %b for restarting, count: %d \n\n' 'PID\x27s' "${nn}"

        sleep 1 # <>

      : 'for each signal and for each PID...'
      for pp in "${!a_pids[@]}"
      do

        ## Note: readability

        :
        : $'\x60kill\x60 '"loop $(( ++ii )) of ${nn}"
        :
        qq="${a_pids[pp]}"

        [[ ${qq} -eq 1 ]] && continue 002
        sleep 1

        for ss in HUP USR1 TERM KILL
        do

          sleep 1
          sync --file-system

            wait -f # <>

          : '...if the PID is still running...'
          if ps --no-headers --quick-pid "${qq}" > /dev/null
          then

            : '...then \kill\ it with the according per-loop SIGNAL...'

            ## Note: the exit codes for \x60kill\x60 only indicate whether or not the target PIDs existed, rather
            #+ than whether the \x60kill\x60 operation succeeded, per \x60info kill\x60.

            sudo -- kill --signal "${ss}" -- "${qq}"

            : '...and if the PID in question no longer exists then unset the current array index number'
            if ps --no-headers --quick-pid "${qq}" > /dev/null 2>&1
            then
              continue 0001
            else
              unset 'a_pids[pp]'
              break 0001
            fi
          else
            break 001
          fi
        done
      done
    else
      break 1
    fi
  done
  unset nn ss pp qq a_pids
fi

  #ec=101 nn="$nL" exit # <>
  #set -x # <>

## TODO: use written function here

: 'Restart NetworkManager if necessary'
for nn in "${dns_srv_A}" "${dns_srv_1}"
do
  if ! ping -4qc1 -- "${nn}" > /dev/null 2>&1
  then
    sudo -- nice --adjustment=-20 -- systemctl restart -- NetworkManager.service || er_x "${nL}"
  fi
done

# <Logs> Write to TTY and exit
#kill --signal USR2 -- "$$" # <Logs>

printf '  %s - Done \n' "$( date +%H:%M:%S )"
ec='00' nn="$nL" exit

