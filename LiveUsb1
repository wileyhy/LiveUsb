#!/bin/bash
## #!/bin/env -iS bash

## Note: use `env -i` or else the script's execution environment will inherit any exported anything, 
#+  including and especially functions, from its caller, e.g., any locally defined functions (such as `rm`!)
#+  which might be intended to supercede any of the aliases which some Linux distributions often define and
#+  provide for users' convenience.  These exported functions which are received from the caller's
#+  environment get printed above the script's shebang in xtrace when xtrace and vebose are both enabled on the shebang line.
#+  ...also, using `env` messes up vim's default bash-colorizations

## LiveUsb1

## Note, written from within a Fedora instance, see hardcoded /run/media/root'
## Note, style, function definition syntax, '(){ :' makes plain xtrace easier to read
## Note, style, `! [[ -e` doesn't show the '!' in xtrace, whereas `[[ ! -e` does.
## Note, idempotent script

# <> Debugging
set -aCuTeo pipefail # <>
#set -x

:;: 'Variables likely to be manually changed with some regularity'
# shellcheck disable=SC2034
{
  files_for_use_with_github_level_1=( ~/.ssh ~/.gnupg ~/.vimrc ~/.mozilla )
  files_for_use_with_github_level_2=( ~/.config/gh )
  files_for_use_with_github_level_3=( ~/.config/procps/toprc )
  arrays_of_conf_files=( files_for_use_with_github_level_1 files_for_use_with_github_level_2
    files_for_use_with_github_level_3 )
}

umask 077
hash -r

fn_bndry=' ~~~ ~~~ ~~~ '
fn_lvl=0
scr_nm='LiveUsb1.sh'

:;: 'Write to TTY'
TT=$( date +%H:%M:%S )
printf '  %s - Executing %s \n' "${TT}" "$0"
unset TT

##  FUNCTION DEFINITIONS, BEGIN ##

:;: $'redefine all functions to be appended into bashrc, so start by \x60unset\x60ing them'
fns_for_appending_into_bashrc=( '__vte_osc7' '__vte_prompt_command' 'rm' )
for AA in "${fns_for_appending_into_bashrc[@]}"
do
  unset -f "$AA"
done
unset AA

:;: 'Functions TOC...'
  ## functions_this_script=(
  #+	'__vte_osc7()'
  #+	'__vte_prompt_command()'
  #+	'er_x()'
  #+	'get_pids_for_restarting()'
  #+  'gh_auth_login_command()'
  #+  'min_necc_git_cmds()'
  #+  'min_necc_packages()'
  #+	'must_be_root()'
  #+  'pause_to_check()'
  #+  'reqd_user_files()'
  #+	'rm()'
  #+  'rsync_install_if_missing()'
  #+  'setup_network()'
  #+  'setup_time()'
  #+	'test_dns()'
  #+  'test_os()'
  #+  'trap_exit()'
  #+	'write_bashrc_strings()'
  #+)

:;: 'Define __vte_osc7() -- for bashrc only'
# shellcheck disable=SC2317
function __vte_osc7(){
  local - cmd urlencode_o
  set -

  cmd=$( PATH="${PATH}:/usr/libexec:/usr/lib:/usr/lib64" command -v vte-urlencode-cwd )
  [[ -n ${cmd} ]] || return
  urlencode_o=$( "${cmd}" )

  ## Bug, what does this cmd do?
  printf '\033]7;file://%s%s\033' "${HOSTNAME}" "${urlencode_o:-"${PWD}"}"
}

:;: 'Define __vte_prompt_command() -- for bashrc only'
# shellcheck disable=SC2317
function __vte_prompt_command(){
  local - prompt_cmd pwd
  set -

  prompt_cmd=$( HISTTIMEFORMAT='' history 1 | sed 's/^ *[0-9]\+ *//' )
  prompt_cmd="${prompt_cmd//;/ }"
  pwd=~

  if ! [[ ${PWD} = ~ ]]
  then
    pwd="${PWD/#"${HOME}"\//\~\/}"
    pwd="${pwd//[[:cntrl:]]}"
  fi

  ## Bug, what does this cmd do?
  printf '\033[m\033]7;%s@%s:%s\033' "${USER}" "${HOSTNAME%%.*}" "${pwd}"
  __vte_osc7
}

:;: 'Define er_x()'
function er_x(){ local - hyphn="$-" exit_code="$?" _="${fn_bndry} er_x() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"

  printf '%s, Error, %s\n' "$scr_nm" "$*" >&2

  true "${fn_bndry} er_x() ENDS ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"

  exit "${exit_code}"
}

:;: 'Define get_pids_for_restarting()'
function get_pids_for_restarting(){ :
  local - hyphn="$-" _="${fn_bndry} get_pids_for_restarting() BEGINS ${fn_bndry} ${fn_lvl} to $((++fn_lvl))"

  ## Note,  local -Ig  picks up attributes and values from global scope and also outputs same to global
  #+  scope.
  # shellcheck disable=SC2034
  local - dnf_o pipeline1 pipeline2
  local -Ig a_pids
  dnf_o=$( sudo -- nice --adjustment=-20 -- dnf needs-restarting 2> /dev/null || er_x "${nL}" )

  ## Note, this pipeline was broken out into its constituent commands in order to verify the values
  #+  mid-stream
  pipline1=$( awk '{ print $1 }' <<< "${dnf_o}" )
  pipline2=$( grep --only-matching --extended-regexp ^'[0-9]*'$ <<< "${pipline1}" )

  readarray -d '' -t a_pids < <( tr '\n' '\0' <<< "${pipline2}" )

  true "${fn_bndry} get_pids_for_restarting()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define gh_auth_login_command()'
function gh_auth_login_command(){ :
  local - hyphn="$-" _="${fn_bndry} gh_auth_login_command() BEGINS ${fn_bndry} ${fn_lvl} to $((++fn_lvl))"
  # set -

  if gh auth status
  then
    gh auth logout
  fi

  ## Note, do not break this line with any backslashed newlines or it will fail and you'll have to
  #+  refresh auth manually; using short options for just this reason
  gh auth login -p 'ssh' -h 'github.com' -s 'admin:public_key,read:gpg_key,admin:ssh_signing_key' -w ||
    exit "${nL}"

  : 'gh - Use GitHub CLI as a credential helper'
  git config --global credential.helper "cache --timeout=3600"
  gh auth setup-git

  true "${fn_bndry} gh_auth_login_command()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'min_necc_git_cmds()'
function min_necc_git_cmds(){ :
  local - hyphn="$-" _="${fn_bndry} min_necc_git_cmds() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  set -

  git config --global 'user.email' '84648683+wileyhy@users.noreply.github.com'
  git config --global 'user.name' 'Wiley Young'
  git config --global 'user.signingkey' 'E287D0CF528591CE'

  true "${fn_bndry} min_necc_git_cmds()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define min_necc_packages()'
function min_necc_packages(){ :
  local - hyphn="$-" _="${fn_bndry} min_necc_packages() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  #set -

  local XX 
  local -a a_pids

  for XX in git gh ShellCheck
  do
    if ! rpm --query --quiet "$XX"
    then
      sudo dnf --assumeyes install "$XX"

      unset -v a_pids
      local -a a_pids=()
      get_pids_for_restarting

    fi
  done

  true "${fn_bndry} min_necc_packages()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define must_be_root()'
function must_be_root(){ :
  local - hyphn="$-" _="${fn_bndry} must_be_root() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  #set -

  if (( UID == 0 ))
  then
    er_x Must be a regular user and use sudo
  else
    sudo --validate || er_x "${nL}"
  fi

  true "${fn_bndry} must_be_root()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define pause_to_check()'
## Usage,   pause_to_check $nL
function pause_to_check() { local EC=101 LL="$1"
  set -x ## sb global ?
  local - hyphn="$-" reply _="${fn_bndry} pause_to_check() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  set - ## sb local ?
  shift
  local -a MM=( "$@" )

  [[ -n ${MM[*]:0:1} ]] && printf '\n%s, pause_to_check(), %s\n' "${scr_nm}" "${MM[@]}" >&2
  printf '\n[Y|y|(enter)|(space)] is yes\nAnything else is { no and exit }\n' >&2
  read -N1 -p $'\nReady?\n' -rst 600 reply >&2

  case $reply in
    Y*|y*|$'\n'|' ' )
      printf '\nOkay\n\n' >&2
      ;;\
    * )
      printf '\nExiting, line %d\n\n' "${LL}" >&2
      builtin exit
      ;;\
  esac

  local bndry_cmd
  if [[ $hyphn =~ x ]]; then bndry_cmd='echo'; else bndry_cmd='true'; fi
  "${bndry_cmd}"  "${fn_bndry} pause_to_check()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'reqd_user_files()'
function reqd_user_files(){ :
  local - hyphn="$-" _="${fn_bndry} reqd_user_files() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  #set -

  ## Note, NN must be declared as local before unsetting it inside the function so that the `unset` will
  #+  effect the local variable
  local pttn_label mount_pt data_dir
  pttn_label='29_Mar_2023'
  mount_pt="/run/media/root/${pttn_label}"
  data_dir="${mount_pt}/skel-LiveUsb"

  local AA
  local -n NN
  ## It isn't necessary to declare NN as a nameref, since unsetting NN (see below) removes the nameref
  #+  attribute, but I intend to use NN as a nameref, so declaring NN without a nameref attribute would be
  #+  confusing

  : 'Vars: get list of mounts'
  ## Note, and yet, when locally declaring and assigning separately a regular variable, ie,
  #+  `local lsblk_out` \n `lsblk_out=''` the assignment doesn't need a preceding `local`
  ## Note, I'm using an array with $lsblk_out so I can work around `set -u` by using a ':=' PE, and so that
  #+  I can limit xtrace output by testing for a shortened version of the output of `lsblk`. I.e., I'm testing
  #+  the last line of the array, index '-1', but this is really just a practice, since a lot of times index
  #+  zero gets unset for whatever reason, but if there are any values in the array at all, then index
  #+  '-1' is guaranteed to exist. ...unless the array is completely empty...
  #+	but I don't want to UNSET ie RESET the array on each loop. If it's actually empty, I want to fill
  #+  it, but i
  #+ In this script, index zero should exist, barring any future changes. So,
  #+  it's a bit of future-proofing.
  local -a lsblk_out
  readarray -d '' -t lsblk_out < <( lsblk --output label,path,mountpoints | awk '{ print $1,$2,$3 }' )
  [[ -n ${lsblk_out[@]} ]] || er_x "${nL}"

  : $'Vars: Get device name where label \x24pttn_label can be found'
  local pttn_path
  pttn_path=$( printf '%s\n' "${lsblk_out[@]}" | awk -v lbl="${pttn_label}" '$1 ~ lbl { print $2 }' )

  :;: 'For each array of conf files and/or directories'
  for AA in "${arrays_of_conf_files[@]}"
  do
    :;: 'Loop A'

    : 'Vars'
    ## Note, if I declare a local nameref, `local -n foo`, then on the next line just assign to the nameref
    #+  directly, `foo=bar`, then on the second loop `local -p NN` prints the former value of NN. Perhaps
    #+  the second assignment statement, ie, `foo=bar` without `local -n` is global?
    ## Note, remember, namerefs can only be unset with the -n flag to the `unset` builtin
    local BB
    unset -n NN
    local -n NN
    local -n NN="${AA}"   ## good code
    #NN="${AA}"           ## bad code

    :;: 'For each conf file or dir'
    for BB in "${!NN[@]}"
    do
      :;: 'Loop B'

      : 'Vars'
      local source_file dest_dir
      source_file="${data_dir}/${NN[BB]#~/}"
      dest_dir="${NN[BB]%/*}"

      :;: 'If the target conf file/dir does not exist'
      if ! [[ -e ${NN[BB]} ]]
      then

        :;: 'If the source conf file/dir does not exist, then find it'
        if ! [[ -e "${source_file}" ]]
        then

          : 'If the USB device is NA, then exit'
          if [[ -z $pttn_path ]]
          then
            er_x "${nL} USB device not available, ${pttn_label}"
          fi

          : 'If the partition is not mounted which holds the data directory, then mount it'
          if ! grep --quiet "$mount_pt" <<< "${lsblk_out[@]}" # <>
          then

            : 'Mountpoint must exist'
            if ! [[ -d "${mount_pt}" ]]
            then
              sudo -- mkdir --parents -- "${mount_pt}" || er_x "${nL}"
            fi

            : $'Perform mount operation and re-sample \x60lsblk\x60'
            sudo -- mount -- "${pttn_path}" "${mount_pt}" || er_x "${nL}"

            readarray -t lsblk_out < <( lsblk --output label,path,mountpoints )
          fi

          :;: 'If the source conf still file/dir does not exist, then throw an error'
          if ! [[ -e "${source_file}" ]]
          then
            er_x "$nL" "${NN[BB]}" "${source_file}"
          fi
        fi

        : 'Capture previous umask'
        local prev_umask
        read -r -a prev_umask < <( umask -p )
        umask 077

        rsync_install_if_missing  "${source_file}" "${dest_dir}"

        builtin "${prev_umask[@]}"
      fi
    done
  done
  unset AA NN

  true "${fn_bndry} reqd_user_files()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define rm() -- for bashrc only'
## Note, rm(), command shadowing is intended in this case
function rm(){ :
  local -
  #set -

  :;: 'Input must exist'
  [[ ${#@} -eq 0 ]] && return "$LINENO"

  :;: 'For each positional parameter'
  local HH end_of_options opts_rm args_rm

  for HH
  do
    : 'If "End of Options" has (not) been reached'
    if ! [[ ${end_of_options:=} = 'has_been_reached' ]]
    then
      case "${HH}" in
        --version )
          command -- rm --version
          ;;
        --help )
          command -- rm --help
          ;;
        -- )
          end_of_options='has_been_reached'
          opts_rm+=( "${HH}" )
          ;;
        -f|--force|-i|--interactive|--interactive=always|-I|--interactive=once|--interactive=never|\
        --one-file-system|--no-preserve-root|--preserve-root|--preserve-root=all|-r|-R|--recursive|\
        -d|--dir|-v|--verbose )
          opts_rm+=( "${HH}" )
          ;;
        * )
          : 'No options found; options have concluded'
          end_of_options='has_been_reached'

          : 'If there is no next pos-parm'
          if [[ -z ${2:-} ]] || ! [[ $2 = -- ]]
          then
            : '...then force end of arguments on the CLI'
            opts_rm+=( -- )
          else
            : $'...or if the next pos-parm isn\x60t a valid FSO (File System Object)'
            if ! [[ -e $2 ]] || ! [[ -d $2 ]]
            then
              : '...then force end of arguments on the CLI'
              opts_rm+=( -- )
            fi
          fi

          if [[ -e ${HH} ]]
          then
            JJ=$( realpath -e "${HH}" )
            args_rm+=( "${JJ}" )
          else
            : $'rm: unrecognized option \x27'"${HH}"$'\x27\n'
            : $'Try \x27rm --help\x27 for more information.'
          fi
          unset JJ
          ;;
      esac
    else
      : 'Yes, so options are over and only arguments are processed'

      if [[ -e ${HH} ]]
      then
        II=$( realpath -e "${HH}" )
        args_rm+=( "${II}" )
      else
        : $'fn_rm: cannot access \x27'"${HH}"$'\x27: No such file or directory\n'
        : $'GNU \x60rm\x60 silently ignores such inputs'
      fi
      unset II
    fi

    : 'Restart loop'
    shift
  done
  : 'End of loop'

  : 'Sanity check for options and arguments'
  [[ -z ${opts_rm:=} ]] && opts_rm=( -- )

  :;: '"Recycle bin" must exist'
  local delete_d
  delete_d=~/.rm.d

  if ! [[ -e ${delete_d} ]] || ! [[ -d ${delete_d} ]]
  then
      command -- mkdir --mode 0700 --verbose -- "${delete_d}" || return "$LINENO"
  fi

  :;: 'If optargs exist, then  mv  the file into the recycle bucket, appending the time'
  if [[ -n ${args_rm[*]:0:8} ]]
  then
    local time_sfx
    time_sfx=$( date --utc +%s )

    command -- mv --verbose -- "${HH}" "${delete_d}/${HH}.${time_sfx}" || return "$LINENO"
  fi
}

:;: 'Define rsync_install_if_missing()'
function rsync_install_if_missing(){ :
  local - hyphn="$-" _="${fn_bndry} rsync_install_if_missing() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  set -x

  local fn_target_dir fn_umask fn_source_var
  #set -
  fn_source_var="$1"
  fn_target_dir="$2"

  if [[ -e "${fn_target_dir}" ]]
  then
    if ! [[ -d "${fn_target_dir}" ]]
    then
      er_x "$nL" "${fn_target_dir}"
    fi
  else
    read -r -a fn_umask < <( umask -p )
    umask 077
    mkdir --verbose --parents -- "${fn_target_dir}"
    builtin "${fn_umask[@]}"
    unset fn_umask
  fi

  if ! [[ -e ${fn_target_dir}/${fn_source_var#*"${data_dir}"/} ]]
  then
    sudo -- rsync --archive --checksum -- "${fn_source_var}" "${fn_target_dir}" || er_x "${nL}" "${fn_target_dir}"
  fi
  unset fn_source_var fn_target_dir

  true "${fn_bndry} rsync_install_if_missing() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
}

:;: 'Define setup_network()'
function setup_network(){ :
  local - hyphn="$-" _="${fn_bndry} setup_network() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  #set -x

  dns_srv_1=8.8.8.8
  dns_srv_A=75.75.75.75
  readonly dns_srv_1 dns_srv_A

  if ! test_dns "${dns_srv_1}" || ! test_dns "${dns_srv_A}"
  then
    printf '\n%s, Attempting to connect to the internet... \n\n' "$scr_nm"

    : 'Try to get NetworkManager up and running'
    sudo -- nice --adjustment=-20 -- systemctl start -- NetworkManager.service
    wait -f

    : 'Turn on networking'
    sudo -- nmcli n on

    : 'Turn on WiFi'
    sudo -- nmcli r wifi on

    : 'Get interface name(s)'
    readarray -d '' -t ifaces < <( nmcli --terse c |
      awk --field-separator ':' '$1 !~ /lo/ { printf "%s\0", $1 }' )

    : 'Connect the interface'
    case "${#ifaces[@]}" in
      0 )
        er_x "line,${nL}, No network device available"
        ;;\
      1 )
        nmcli c up "${ifaces[*]}"
        sleep 5
        ;;\
      * )
        er_x "line ${nL}, Multiple network devices available"
        ;;\
    esac

    if ! test_dns "${dns_srv_1}" || ! test_dns "${dns_srv_A}"
    then
      printf '\n%s, Network, Giving up, exiting.\n\n' "$scr_nm"
    else
      printf '\n%s, Network, Success!\n\n' "$scr_nm"
    fi
  fi

  ## Clean up from Network
  ## Note, dns_srv_A will be used at the end of the script
  unset -f test_dns

  true "${fn_bndry} setup_network()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define setup_time()'
function setup_time(){ :
  local - hyphn="$-" _="${fn_bndry} setup_time() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"

  sudo -- timedatectl set-local-rtc 0
  sudo -- timedatectl set-timezone America/Vancouver
  sudo -- nice --adjustment=-20 -- systemctl start chronyd.service || er_x "line ${nL}"
  sudo -- chronyc makestep > /dev/null

  true "${fn_bndry} setup_time()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

:;: 'Define test_dns()'
function test_dns(){ :
  local - hyphn="$-" _="${fn_bndry} test_dns() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  #set -

  sudo -- ping -c 1 -W 15 -- "$1" > /dev/null 2>&1
  ping_exit_code=$?

  true "${fn_bndry} test_dns()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
  return "${ping_exit_code}"
}

:;: 'Define test_os()'
function test_os(){ :
  local - hyphn="$-" _="${fn_bndry} test_os() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"

  local kern_rel
  kern_rel=$( uname --kernel-release )

  ## Note, test of $kern_rel is a test for whether the OS is Fedora (ie, "fc38" or "Fedora Core 38")
  if ! [[ ${kern_rel} =~ \.fc[0-9]{2}\. ]]
  then
    er_x "${LINENO}, OS is not Fedora"
  fi

  true "${fn_bndry} test_os()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

## Bug, these var assignments $exit_trap_ec and $lineno only fail when they're on line number >=2
#+  of  trap  "args section" ??

:;: 'Define trap_exit()'
## Note: these variable assignments must be on the 1st line of the funtion in order to capture correct data
# shellcheck disable=SC2317
function trap_exit(){ local - hyphn="$-" exit_trap_ec="${EC:-$?}" lineno="${LL:-$LINENO}"
  true "${fn_bndry} trap_exit() BEGINS ${fn_bndry} ${fn_lvl} to $(( ++fn_lvl ))"
  set -

  #if [[ -e ${tmpd} ]]
  #then
    #command rm --one-file-system --preserve-root=all --force --recursive -- "${tmpd}"
  #fi

  trap - EXIT

  if [[ ${exit_trap_ec} -eq '00' ]]
  then
    : "End of script, line ${lineno}"
  else
    : 'End of EXIT trap'
  fi

  true "${fn_bndry} trap_exit()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"

  builtin exit "${exit_trap_ec}"
}

:;: 'Define write_bashrc_strings()'
function write_bashrc_strings(){ :
  local - hyphn="$-" _="${fn_bndry} write_bashrc_strings() BEGINS ${fn_bndry} ${fn_lvl} to $((++fn_lvl))"
  set -x

  local JJ file_x Aa_index Aa_element
  local -n fn_nameref

  :;: 'Certain parameters must be defined and have non-zero values'
  ((                             $# == 0 )) && er_x "line ${nL}"
  (( ${#files_for_use_with_bash[@]} == 0 )) && er_x "line ${nL}"

  for JJ
  do :;: 'Loop A - For each set of strings to append into bashrc'

    fn_nameref="$JJ"

    for file_x in "${files_for_use_with_bash[@]}"
    do :;: 'Loop B - For each .bashrc'

      : "file_x  ${file_x}"

      for Aa_index in "${!fn_nameref[@]}"
      do :;: 'Loop C - For each definition (function or parameter)'

        : "Aa_index  ${Aa_index}"
        Aa_element="${fn_nameref[${Aa_index}]}"

        :;: '(1) If the definition is not yet written into the file...'
        if ! sudo -- grep --quiet --fixed-strings "## ${Aa_index}" -- "${file_x}"
        then

          : 'Then write the function definition into the file'
          printf '\n## %s \n%s \n' "${Aa_index}" "${Aa_element}" |
            sudo -- tee --append -- "${file_x}" > /dev/null || er_x "${nL}"
        else
          : 'Definition exists, skipping'
        fi

        :;: '(2) If there is an alias by the same name, then delete it from the bashrc file at hand...'
        sudo -- sed --in-place "/^alias ${Aa_index##* }=/d" -- "${file_x}"

        : 'Loop C - shut' ;:
      done
      unset Aa_element
      :;: 'Loop C - complete'

      :;: 'For each file, if absent add a newline at EOF'
      if sudo -- tail --lines 1 -- "${file_x}" | grep --quiet --extended-regexp '[[:graph:]]'
      then
        printf '\n' | sudo -- tee --append -- "${file_x}" > /dev/null
      fi

      : 'Loop B - shut' ;:
    done

    :;: 'Reset for the next loop, assuming there is one'
    ## Note, ?? use  unset  so that values from previous loops will not interfere with the current loop
    unset -n fn_nameref
    shift

    : 'Loop A - shut' ;:
  done
  true "${fn_bndry} write_bashrc_strings()  ENDS  ${fn_bndry} ${fn_lvl} to $(( --fn_lvl ))"
}

##  FUNCTION DEFINITIONS COMPLETE ##

  #EC=101 LL="$LINENO" exit # <>

:;: 'Define trap on EXIT'
trap trap_exit EXIT

:;: 'Test OS'
test_os

:;: 'Vars, dirs, etc'
## Bug, only way to export namerefs?  `declare -nx nL=...`

:;: 'Vars... -- Error handling, variables and functions'
## Note, variable assignments, Backslash escape bc  sed -i
# shellcheck disable=SC1001
declare -nx nL=L\INENO

:;: 'Vars... -- PATH'
PATH='/usr/bin:/usr/sbin'
export PATH

:;: 'Vars... -- Working dir'
tmpd=$( TMPDIR='' mktemp --directory --suffix=-LiveUsb 2>&1 || er_x "${nL}" )
[[ -d ${tmpd} ]] || er_x "${nL}"
scr_tt=$( printf '%(%s)T' )
logf="${tmpd}/log.${scr_nm}.${scr_tt}.txt"

:;: 'Vars... -- Other environment variables'
## Note, Initialize some env vars found in sourced files, as a workaround for nounset'
## Note, local style, inline comments, ie, ': foo ## Note, blah', are useful for rebutting false positives
#+  from ShellCheck
LC_ALL=''
PS1=''
# shellcheck disable=SC2034
declare BASHRCSOURCED USER_LS_COLORS ## Note, /etc/bashrc and /etc/profile.d/colorls.*sh on Fedora 38

:;: '<Logs>'
#set -x
#printf '\n%s, beginning logging to file, %s\n' "${scr_nm}" "${logf}"
#exec > >( tee "${logf}" ) 2>&1

## Note, traps
# EXIT -- for exiting
# HUP USR1 TERM KILL -- for restarting processes
# INT QUIT USR2 -- for stopping logging

:;: 'Regular users with sudo, only'
must_be_root

:;: 'Certain files must have been installed from off-disk'
reqd_user_files

:;: 'Network'
setup_network

:;: 'Time'
setup_time

:;: 'Minimum necessary rpms'
min_necc_packages

:;: 'Minimum necessary git commands'
min_necc_git_cmds

:;: 'gh -- github CLI configuration'
declare -A github_configs
github_configs=( [editor]=vim [browser]=firefox [pager]=less [git_protocol]=ssh )
gh_config_list_out=$( gh config list | tr '\n' ' ' )

for KK in "${!github_configs[@]}"
do
  if ! [[ ${gh_config_list_out} = "${KK}=${github_configs[$KK]}" ]]
  then
    gh config set "${KK}" "${github_configs[$KK]}"
  fi
done
unset gh_config_list_out github_configs KK

:;: 'gh -- Login to github'
## Note, executing this command just once
if ! gh auth status 2>/dev/null 1>&2 || [[ $( gh auth status |& grep --count $'\xe2\x9c\x93' ) -ne 4 ]]
then
  if ! pgrep 'firefox'
  then
    firefox --browser &
    pause_to_check "$nL" 'Waiting till browser is open before running  gh auth  command'
    gh_auth_login_command
  fi
fi

:;: 'gh -- Get SSH & GPG keys'
for QQ in ssh-key gpg-key
do
  if ! gh "${QQ}" list > /dev/null
  then
    gh_auth_login_command
  fi
done
unset QQ

  set -x

:;: 'Bash'

## Note, this section is for .bashrc. VTE functions are from Fedora 38, Sun 09 July 2023, altered from vte.sh
## Note,  set [-|-x] , letting xtrace expand this  tput  command alters all xtrace colorization

:;: 'Env vars for bashrc'

:;: 'Color code assigned to PS0, ducking xtrace'
if [[ -o xtrace ]]
then
  set -
  PS0=$( tput setaf 43 )
  set -x
else
  PS0=$( tput setaf 43 )
fi
PS1="[\\u@\\h]\\\$ "
PROMPT_COMMAND=( [0]="printf '%b' '\\033[m'" [1]="__vte_prompt_command" )
BROWSER=$( command -v firefox )
EDITOR=$( command -v vim )

declare -A bashrc_strings_1 bashrc_strings_2
files_for_use_with_bash=( /root/.bashrc ~/.bashrc )
missing_fns=()

:;: 'Append user variables and functions into .bashrc.'
## Note, these arrays include some command substitutions which depend on some function definitions, which in
#+  turn must be defined prior to defining these arrays

: 'Said functions must have already been defined'
[[ -z ${fns_for_appending_into_bashrc[*]} ]] && er_x "${nL}"

for UU in "${fns_for_appending_into_bashrc[@]}"
do
  if [[ $( declare -pF "${UU}" 2>&1 ) =~ 'not found' ]]
  then
    missing_fns+=( "${UU}" )
  fi
done
unset UU

if (( ${#missing_fns[@]} > 0 ))
then
  er_x "${nL}", "${missing_fns[@]}"
fi

:;: 'Define bashrc_strings_*'
## Note, you want for these array elements to represent just one parameter or function each

: '  bashrc: Functions (a.k.a. "subroutines")'
bashrc_strings_1=(            ['subroutine __vte_osc7']="function $(  declare -pf __vte_osc7 )")
bashrc_strings_1+=( ['subroutine __vte_prompt_command']="function $(  declare -pf __vte_prompt_command )")
bashrc_strings_1+=(                   ['subroutine rm']="function $(  declare -pf rm )")

: '  bashrc: Variables'
bashrc_strings_2=(                   ['define BROWSER']=$(            declare -p BROWSER ) )
bashrc_strings_2+=(                   ['define EDITOR']=$(            declare -p EDITOR ) )
bashrc_strings_2+=(           ['define PROMPT_COMMAND']=$(            declare -p PROMPT_COMMAND ) )
bashrc_strings_2+=(                      ['define PS0']=$(            declare -p PS0  ) )

:;: 'Do some backups'
for VV in "${files_for_use_with_bash[@]}"
do
  : 'File must exist'
  if ! sudo -- [ -f "${VV}" ]
  then
    er_x "line ${nL}, ${VV}"
  fi

  : '...of the array files_for_use_with_bash'
  if ! sudo -- [ -e "${VV}.orig" ]
  then
    sudo -- rsync --checksum --archive -- "${VV}" "${VV}.orig"
    sudo -- chmod 400 -- "${VV}.orig"
    sudo -- chattr +i -- "${VV}.orig"
  fi

  : '...per-script-execution file backup'
  sudo -- cp --archive -- "${VV}" "${VV}~" || er_x "line ${nL}, ${VV}"
done
unset VV

:;: 'Write functions and variable definitions into bashrc files'
write_bashrc_strings "bashrc_strings_1" "bashrc_strings_2"

## Clean up from section Bash
unset files_for_use_with_bash bashrc_strings_1 bashrc_strings_2
unset -f write_bashrc_strings

  EC=101 LL="${nL}" exit

:;: 'Vim'

: 'Heredoc of vim-conf-text'
cat <<- \EOF | tee -- "${tmpd}/vim-conf-text" > /dev/null
	" ~/.vimrc

	" per Google
	set number

	" per https://stackoverflow.com/questions/234564/tab-key-4-spaces-and-auto-indent-after-curly-braces-in-vim
	filetype plugin indent on
	" show existing tab with 2 spaces width
	set tabstop=2
	" when indenting with '>', use 2 spaces width
	set shiftwidth=2
	" On pressing tab, insert 2 spaces
	set expandtab

	" per https://superuser.com/questions/286290/is-there-any-way-to-hook-saving-in-vim-up-to-commiting-in-git
  autocmd BufWritePost * execute '! if [[ -d .git ]]; then git commit -S -a -F -; fi'

EOF

: $'Get an array of the FS location\x28s\x29 of root\x27s vimrc\x28s\x29'
readarray -d '' -t arr_vrc < <( sudo -- find /root -name '*vimrc*' -print0 )

case "${#arr_vrc[@]}" in
  0 )
      strng_vrc=/root/.vimrc
    ;;\
  1 )
      strng_vrc="${arr_vrc[*]:=/root/.vimrc}"
    ;;\
  *)
      printf '\n  Multiple .vimrc files found, please edit the filesystem.\n' >&2
      printf '\t%s\n' "${arr_vrc[@]}" >&2
      er_x "${nL}"
    ;;\
esac

if (( "${#arr_vrc[@]}" == 1 ))
then
  read -r WW XX < <( sudo -- sha256sum -- "${tmpd}/vim-conf-text" 2>&1 )
  read -r YY XX < <( sudo -- sha256sum -- "${strng_vrc}" 2>&1 )
else
  sudo -- touch -- "${strng_vrc}" # <> set-e
fi

: 'Write .vimrc'
if (( ${#arr_vrc[@]} == 0 )) || ! [[ ${WW} = "${YY}" ]]
then
  : $'Test returned \x22true,\x22 the number didn\x27t match, so write to .vimrc'

  : 'Set the umask'
  read -ra umask_prior < <( umask -p )
  umask 177

  : 'Write the root file'
  sudo -- rsync --archive --checksum -- "${tmpd}/vim-conf-text" "${strng_vrc}" || er_x "${nL}"

  : $'Copy the root file to ~liveuser and repair DAC\x27s on liveuser\x27s copy'
  sudo -- rsync --archive --checksum -- "${strng_vrc}" "/home/${USER}/.vimrc" || er_x "${nL}"
  sudo -- chown "${UID}:${UID}" -- "/home/${USER}/.vimrc"
  chmod 0400 -- "/home/${USER}/.vimrc"

  : 'Reset the umask'
  builtin "${umask_prior[@]}"
fi

## Clean up after section Vim
command -- rm --one-file-system --preserve-root=all --force -- "${tmpd}/vim-conf-text"
unset arr_vrc strng_vrc write2fs WW XX YY umask_prior

:;: 'Disk space, increase available by removing non-local locales'

## Note, such as...   /usr/lib/locale /usr/share/i18n/locales /usr/share/locale /usr/share/X11/locale , etc.
## Note, for $dirs1 , find  syntax based on Mascheck's
## Note, for $dirs2 , use of bit bucket because GVFS ‘/run/user/1000/doc’ cannot be read, even by root
## Note, for $fsos3 , '--and' is not POSIX compliant
## Note, for $fsos4 , sorts by unique inode and delimits by nulls

## Bug, Hardcoded path, for $dirs2 , '/run/media/root' is a default for mounting external media on
#+  Fedora-like systems

declare -A fsos5
readarray -d '' -t dirs1 < <( find / ! -path / -prune -type d -print0 )

readarray -d '' -t dirs2 < <(
  find "${dirs1[@]}" -type d -name '*locale*' ! -ipath '*/run/media/root/*' -print0 2> /dev/null )

readarray -d '' -t fsos3 < <(
  find "${dirs2[@]}" -type f -size +2048b '(' ! -ipath '*en_*' -a !  -ipath '*/.git/*' ')' -print0 )

if (( ${#fsos3[@]} > 0 ))
then
  ## Note, for loop is run in a subshell, so unsetting ZZ is unnecessary
  readarray -d '' -t fsos4 < <( {
    for ZZ in "${fsos3[@]}"
    do
      printf '%s\0' "$( stat --printf='%i %n\n' -- "${ZZ}" )"
    done ; } |
      sort --unique |
      tr --delete '\n'
    )

  ## Question, does this assoc array fsos5 need to be declared as such? (I don't think so, but...)

  set -- "${fsos4[@]}"

  while true
  do
    [[ -z ${1:-} ]] && break 1 # <> set-u

    # shellcheck disable=SC2190
    fsos5+=( "${1%% *}" "${1#* }")
    shift 1

    (( $# == 0 )) && break 1
  done
fi

: 'If any larger local data files were found, then remove them interactively'
if [[ -n ${!fsos5[*]} ]]
then
  : 'Inform user of any found FSOs'
  printf '%s, Delete these files? \n' "${scr_nm}"
  declare -p fsos5
  sleep 3

  for AA in "${!fsos5[@]}"
  do
    HH=0
    II=0
    JJ="${fsos5[$AA]#.}"
    printf '%s,   File %d, \n' "${scr_nm}" "$(( ++II ))"

    while true
    do
      if [[ -e ${JJ} ]]
      then
        declare ls_out        
        readarray -t ls_out < <( ls -l --all --human-readable --classify --inode --directory --zero "${JJ}" )
        ## Note, '\x60' is a "backtick"
        printf '%s, output of %bls%b, %s \n' "${scr_nm}" '\x60' '\x60' "$( realpath -e "${JJ}" )"
        printf '%s\n' "${ls_out[@]}"
        unset ls_out

        read -r -p ' > [yN] ' -t 600 yes_or_no
        yes_or_no="${yes_or_no,,?}"
        yes_or_no="${yes_or_no:=n}"

        case "${yes_or_no}" in
          0|1)  printf '  Zero and one are ambiguous, please use letters. \n'
                continue 0001
              ;;\
          y|t)  printf '  %s %b %s %s \n' 'Script,' ' \x60rm -i\x60 ' 'requires a typed [yN] response,' \
                  'it defaults to do-not-delete if a user just presses [enter].'

                if sudo -- command rm --one-file-system --preserve-root=all --interactive -- "${JJ}"
                then
                  unset 'fsos5[$AA]'
                  break 00001
                else
                  er_x "${nL}, unknown error"
                fi
              ;;\
          n|f)  printf '  Keeping this file. \n'
                unset 'fsos5[$AA]'
                break 00001
              ;;\
          *)    HH=$(( ++HH )) # <> set-e, can be just  (( HH++ ))  when errexit's off

                if (( HH < 3 ))
                then
                  printf '  Invalid response (%d), please try again. \n' "${HH}"

                else
                  printf '  Keeping this file. \n'
                  unset 'fsos5[$AA]'
                  break 00001
                fi
              ;;\
        esac
      else
        break 0001
      fi
    done
  done
fi

## Clean up from section "Disk space"
unset dirs1 dirs2 fsos3 fsos4 fsos5 AA HH II JJ yes_or_no

#:;: '<Logs>'
#set -x # <Logs>
#printf '\n%s, beginning logging to file, %s\n' "${scr_nm}" "${logf}" # <Logs>
#exec 3>&1 4>&2 # <Logs>
#trap 'trap - INT QUIT USR2; exec 2>&4 1>&3' INT QUIT USR2 # <Logs>
#exec 1> "${logf}" 2>&1 # <Logs>

:;: '<Logs>'
printf '\n%s, beginning logging to file, %s\n' "${scr_nm}" "${logf}" # <Logs>
set -x # <Logs>
#exec > >( tee "${logf}" ) 2>&1 ## this works. however, there aren't any colors. 
#exec > >( tee --append "${logf}" ) ## 
exec 2> >( GREP_COLORS='mt=01;33' grep --color=always -Ee '.*' | tee --append "${logf}" ) ## 

:;: 'Dnf'

## Bug, there should be a n\eeds-restarting loop between each install/upgrade
## Bug, the --security upgrade should be done rpm by rpm

  : 'Beginning section on DNF' # <>

## Note, CUPS cannot be safely removed; too many dependencies
## Note, For some unknown reason, even when  dnf  doesn't change any programs,  dnf
#+  needs-restarting  decides it needs to restart all available Firefox processes, which crashes all of
#+  my tabs.  (Bug?)  So, I'm adding in a few  rpm -qa | wc -l s to only run  dnf
#+  needs-restarting  in the event that any files on disk may actually have been changed.
## Note, these PE's (for_admin, for_bash, etc.) have been tested and should "disappear" by virtue of
#+  whichever expansion does that, leaving just the regular strings as the elements of the array
## Note, this brace grouping (all together of for_admin, for_bash, etc.) is so that "shellcheck disable" will
#+  apply to the entire block

hash_of_installed_pkgs_A=$( rpm --all --query | sha256sum | awk '{ print $1 }' )

## Removals for disk space
pkg_nms_for_removal=( google-noto-sans-cjk-vf-fonts mint-x-icons mint-y-icons transmission )

## Removals for security
#pkg_nms_for_removal+=( blueman bluez )

# shellcheck disable=SC2206
{
    addl_pkgs=(  ${for_admin:=}        ncdu pwgen )
    addl_pkgs+=( ${for_bash:=}         bash bash-completion )
  # addl_pkgs+=( ${for_bashdb:=}       bash-devel make autoconf )
    addl_pkgs+=( ${for_critical_A:=}   sudo nss openssh chrony dnf gpgme xfce4-terminal )
    addl_pkgs+=( ${for_critical_B:=}   NetworkManager NetworkManager-{adsl,bluetooth,libnm,ppp} )
    addl_pkgs+=( ${for_critical_C:=}   NetworkManager-{team,wifi,wwan} )
  # addl_pkgs+=( ${for_careful:=}      systemd auditd sssd )
  # addl_pkgs+=( ${for_db_ish:=}       libreoffice-calc )
  # addl_pkgs+=( ${for_bug_rpts:=}     inxi zsh dash mksh lynx )
  # addl_pkgs+=( ${for_char_sets:=}    enca moreutils uchardet )
    addl_pkgs+=( ${for_duh:=}          info plocate pdfgrep wdiff )
    addl_pkgs+=( ${for_firefox:=}      mozilla-noscript mozilla-privacy-badger mozilla-https-everywhere )
    addl_pkgs+=( ${for_fun:=}          supertuxkart )
  # addl_pkgs+=( ${for_gcov:=}         gcc )
    addl_pkgs+=( ${for_git:=}          git gh )
  # addl_pkgs+=( ${for_internet:=}     chromium )
  # addl_pkgs+=( ${for_later_other:=}  memstomp gdb valgrind memstrack kernelshark )
  # addl_pkgs+=( ${for_later_trace:=}  bpftrace python3-ptrace fatrace apitrace x11trace )
    addl_pkgs+=( ${for_linting:=}      ShellCheck strace )
  # addl_pkgs+=( ${for_mo_linting:=}   kcov shfmt patch ltrace )
  # addl_pkgs+=( ${for_lockfile:=}     procmail )
  # addl_pkgs+=( ${for_os_dnlds:=}     debian-keyring )
    addl_pkgs+=( ${for_strings:=}      binutils )
  # addl_pkgs+=( ${for_term_tests:=}   gnome-terminal )
  # addl_pkgs+=( ${for_unicode:=}      xterm rxvt-unicode perl-Text-Bidi-urxvt )
    addl_pkgs+=( ${for_security:=}     orca protonvpn-cli xsecurelock )
}

:;: 'Start with removing any unnecessary RPMs'

if [[ -n ${pkg_nms_for_removal:0:8} ]]
then
  ## Note, this  printf  command uses nulls so that '-e' and '%s.*' will be read as separate indices
  #+  by  readarray
  readarray -d '' -t grep_args < <( printf -- '-e\0%s.*\0' "${pkg_nms_for_removal[@]}" )
  readarray -t removable_pkgs < <(
    rpm --all --query | grep --ignore-case --extended-regexp "${grep_args[@]}" )

  :;: 'Keep a list, just in case an rpm removal accidentally erases something vital'
  if [[ -n ${removable_pkgs[*]:0:8} ]]
  then
    for QQ in "${!removable_pkgs[@]}"
    do
      ## Note,  dnf , do not use [-y|--yes] with this particular command
      if sudo -- nice --adjustment=-20 -- dnf --allowerasing remove -- "${removable_pkgs[QQ]}"
      then
        unset 'removable_pkgs[QQ]'
      else
        er_x Line "${nL}", "${removable_pkgs[QQ]}"
      fi
    done
    unset QQ
  fi
fi

:;: 'Then do a blanket security upgrade'

## Note, the problem with this "blanket security upgrade" is how it includes kernel and firmware. Better to
#+  capture list of rpms in a no-op cmd, filter out impractical (for a LiveUsb) rpms, then upgrade the rest
#+  one by one

## Run this loop until `dnf --security upgrade` returns 0, or 0 upgradable, rpms
while true
do
  ## Get full list of rpms to upgrade, in an array; exit on non-zero
  mapfile -d '' -t pkgs_for_upgrade < <(
    sudo -- dnf --assumeno --security upgrade 2>/dev/null |
      awk '$2 ~ /x86_64|noarch/ { printf "%s\0", $1 }'
    )

  ## remove all *kernel* and *firmware* rpms from $pkgs_for_upgrade array
  for HH in "${!pkgs_for_upgrade[@]}"
  do
    if [[ ${pkgs_for_upgrade[HH]} =~ kernel|firmware ]]
    then
      unset_reason+=( [HH]="${BASH_REMATCH[*]}" )
      unset 'pkgs_for_upgrade[HH]'
    fi
  done
  unset HH

  ## If count of upgradeable rpms is 0, then break loop
  if [[ "${#pkgs_for_upgrade[@]}" -eq 0 ]]
  then
    break
  fi

  ## Upgrade the RPM's one at a time
  for II in "${!pkgs_for_upgrade[@]}"
  do
    if sudo -- dnf --assumeyes --security upgrade -- "${pkgs_for_upgrade[II]}"
    then
      unset 'pkgs_for_upgrade[II]'
    else
      printf 'ERROR %d\n' "${II}"
      break
    fi
  done

  ## Run `dnf needs-restarting`, collecting PID/commandline pairs
  a_pids=()
  get_pids_for_restarting

    declare -p a_pids
    exit 101

  ## Send signals to "needs-restarting" PID's, one at a time, with pauses and descriptions between each
  #+  one, so I can see which signal/process combinations cause any problems. This would be a great job
  #+  for logging.

done

  pause_to_check "$nL" $'Which packages in the \x24addl_pkgs array are already installed?' # <>

:;: 'Find out whether an RPM is installed, one by one'
for UU in "${!addl_pkgs[@]}"
do
  if sudo -- nice --adjustment=-20 -- rpm --query --quiet -- "${addl_pkgs[UU]}"
  then
    pkgs_installed+=( "${addl_pkgs[UU]}" )
    unset 'addl_pkgs[UU]'
  fi
done
unset UU

  pause_to_check "$nL" $'Upgrade any pre-intstalled packages from the \x24addl_pkgs array' # <>

## Note, this section should upgrade rpms one by one

:;: 'Upgrade any installed RPMs from the main list, en masse'
if [[ -n ${pkgs_installed[*]: -1:1} ]]
then
  sudo -- nice --adjustment=-20 -- dnf --assumeyes --quiet upgrade -- "${pkgs_installed[@]}" || er_x "${nL}"
fi

  pause_to_check "$nL" $'From the \x24addl_pkgs array, install the remainder' # <>

:;: 'Install any as yet uninstalled RPMs from the main list as necessary'
not_yet_installed_pkgs=( "${addl_pkgs[@]}" )

if [[ -n ${not_yet_installed_pkgs[*]: -1:1} ]]
then
  ## Note, if you install multiple rpms at the same time, and one of them causes some error, then you have
  #+  no immediate way of knowing which one caused the error

  for VV in "${not_yet_installed_pkgs[@]}"
  do
    sudo -- nice --adjustment=-20 -- dnf --assumeyes --quiet install -- "${VV}" || er_x "${nL}"

    a_pids=()
    get_pids_for_restarting

    if [[ -n ${a_pids[*]:0:1} ]]
    then

      for WW in "${a_pids[@]}"
      do
        ps aux | awk "\$2 ~ /${WW}/ { print }"

        pause_to_check "$nL" 'Execute a lengthy \x60kill --timeout...\x60 command?'

        sudo -- nice --adjustment=-20 -- "$(type -P kill)" --verbose \
          --timeout 1000 HUP \
          --timeout 1000 USR1 \
          --timeout 1000 TERM \
          --timeout 1000 KILL -- "$WW"

        sleep 3

        ps aux | awk "\$2 ~ /${WW}/ { print }"

        pause_to_check "$nL" 'Now do you need to manually restart anything?'

      done
      unset WW
    fi
  done
  unset VV
fi
unset pkg_nms_for_removal addl_pkgs
unset for_{admin,bash,bashdb,db_ish,bug_rpts,duh,firefox,fun,gcov,git,internet,later_{other,trace}}
unset for_{linting,lockfile,os_dnlds,strings,term_tests,unicode}
unset grep_args removable_pkgs rr pkgs_installed not_yet_installed_pkgs

  #df --sync --output=fstype,avail,pcent,target -- . | grep --invert-match ^Type # <>
  #EC=101 LL="$nL" exit # <>
  #set -x # <>

  pause_to_check "$nL" 'Begin section on restarting processes?' # <>

:;: 'Restart any processes that may need to be restarted. Begin by getting a list of any such PIDs'
a_pids=()
get_pids_for_restarting

  #EC=101 LL="$nL" exit # <>

hash_of_installed_pkgs_B=$( rpm --all --query | sha256sum | awk '{ print $1 }' )

if ! [[ ${hash_of_installed_pkgs_A} = "${hash_of_installed_pkgs_B}" ]] || [[ "${#a_pids[@]}" -gt 0 ]]
then
  while true
  do

    ## Note,  [[ ... = , this second test,  [[ ${a_pids[*]} = 1 ]]  is correct; ie, do not use ((...))
    :;: 'if any PID\s were found... ...and if there are any PID\s other than PID 1...'
    if [[ -n ${a_pids[*]: -1:1} ]] && ! [[ ${a_pids[*]} = 1 ]]
    then
      II=0
      XX="${#a_pids[@]}"

      :;: 'Print some info and wait for it to be read'
      ## Note, '\x27' is a single quote
      printf '\n  %b for restarting, count, %d \n\n' 'PID\x27s' "${XX}"

        sleep 1 # <>

      :;: 'for each signal and for each PID...'
      for YY in "${!a_pids[@]}"
      do
        ## Note, readability
        :;: $'\x60kill\x60 '"loop $(( ++II )) of ${XX}" ;:

        ZZ="${a_pids[YY]}"
        (( ZZ == 1 )) && continue 001
        sleep 1

          pause_to_check "$nL" '' # <>

        for AA in HUP USR1 TERM KILL
        do

            : "To kill PID $ZZ with signal $AA" # <>
            pause_to_check "$nL" # <>

          #sleep 1
          sync --file-system

            wait -f # <>

          :;: '...if the PID is still running...'
          if ps --no-headers --quick-pid "${ZZ}"
          then

            :;: '...then \kill\ it with the according per-loop SIGNAL...'
            ## Note, the exit codes for  kill  only indicate whether or not the target PIDs existed, rather
            #+ than whether the  kill  operation succeeded, per  info kill .
            sudo -- "$(type -P kill)" --signal "${AA}" -- "${ZZ}"

            :;: '...and if the PID in question no longer exists then unset the current array index number'
            if ps --no-headers --quick-pid "${ZZ}"
            then
              is_zombie=$( ps aux | awk "\$2 ~ /${ZZ}/ { print \$8 }" )

              if [[ ${is_zombie} = 'Z' ]]
              then
                : 'Process is a zombie; unsetting'
                unset 'a_pids[YY]'
                break 00001
              else
                continue 00001
              fi
            else
              unset 'a_pids[YY]'
              break 0001
            fi
          else
            unset 'a_pids[YY]'
            break 001
          fi
        done
        unset AA
      done
      unset YY ZZ
    else
      break 1
    fi
  done
  unset II XX a_pids is_zombie
fi

  #EC=101 LL="$nL" exit # <>
  #set -x # <>

:;: 'Restart NetworkManager if necessary'

## TODO: use written function here
for BB in "${dns_srv_A}" "${dns_srv_1}"
do
  if ! ping -4qc1 -- "${BB}" > /dev/null 2>&1
  then
    sudo -- nice --adjustment=-20 -- systemctl restart -- NetworkManager.service || er_x "${nL}"
  fi
done
unset BB

# <Logs> Write to TTY and exit
#"$(type -P kill)" --signal USR2 -- "$$" # <Logs>

printf '  %s - Done \n' "$( date +%H:%M:%S )"
EC='00' LL="$nL" exit

